// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni

/**Class implementing secp256k1 used in Bitcoin */
declare class NJSSecp256k1
{
    /**
     * Create an instance of Secp256k1
     * @return Secp256k1 instance
     */
    static declare function createInstance(): NJSSecp256k1;
    /**
     * Generates public key from private key.
     * @param privKey 32 byte private key
     * @param compress get compressed (35 bytes) or uncompressed (65 bytes)
     * @return public key can be compressed (35 bytes starting with 02 or 03) or un compressed (65 bytes starting with 04)
     */
    declare function computePubKey(privKey: Object, compress: boolean): Object;
    /**
     * Signs message using a given private key
     * @param privKey 32 bytes private key
     * @param data 32 bytes message to sign
     * @return 32 bytes signed message
     */
    declare function sign(privKey: Object, data: Object): Object;
    /**
     * Check if message was signed with given signature and public key
     * @param data 32 bytes signed message
     * @param signature 32 bytes signature (generated from private key)
     * @param oubkey 32 bytes public key
     * @return true if message was signed with signature and public key (both issued from same private key)
     */
    declare function verify(data: Object, signature: Object, pubKey: Object): boolean;
    static declare function newInstance(): NJSSecp256k1;
}
declare class NJSNetworks
{
    static declare function bitcoin(): BitcoinLikeNetworkParameters;
}
/** Helper class for commonly used crypto algorithms */
declare class NJSHashAlgorithmHelper
{
    /**
     *RACE Integrity Primitives Evaluation Message Digest (used in Bitcoin)
     *@param data in bytes, message to hash
     *@return 160 bits hashed message
     */
    declare function ripemd160(data: Object): Object;
    /**
     *Secure Hash Algorithm (used in Bitcoin)
     *@param data in bytes, message to hash
     *@return 256 bits hashed message
     */
    declare function sha256(data: Object): Object;
    /**
     *Hash algorithm used in ethereum
     *@param data in bytes, message to hash
     *@return 256 bits hashed message
     */
    declare function keccak256(data: Object): Object;
}
/**Class representing an event */
declare class NJSEvent
{
    /**
     *Get event code (for more details, please refer to EventCode enum)
     *@return EventCode enum entry
     */
    declare function getCode(): EventCode;
    /**
     *Get payload of event
     *@return DynamicObject object
     */
    declare function getPayload(): NJSDynamicObject;
    /**
     *Know if event is sticky one
     *@return bool
     */
    declare function isSticky(): boolean;
    /**
     *If event is sticky, return sticky tag
     *@return 32 bits integer
     */
    declare function getStickyTag(): number;
    /**
     *Create a new instance of Event class
     *@param code, EventCode enum entry
     *@param payload, DynamicObject object
     *@return Event instance
     */
    static declare function newInstance(code: EventCode, payload: NJSDynamicObject): NJSEvent;
}
/**Class respresenting an event receiver */
declare class NJSEventReceiver
{
    /**
     *Method triggered when an event occurs
     *@param event, Event object that triggers this method
     */
    declare function onEvent(event: NJSEvent);
}
/**Class representing an event bus through which a receiver gets notified */
declare class NJSEventBus
{
    /**
     *Subscribe an event receiver to the event bus
     *@param context, ExecutionContext object, execution context in which receiver will be notified
     *@param reveiver, EventReceiver object, receiver that event bu will notify
     */
    declare function subscribe(context: NJSExecutionContext, receiver: NJSEventReceiver);
    /**
     *Unsubscribe an event receiver from the event bus
     *@param receiver, EventReceiver object, receiver to unsubscribe
     */
    declare function unsubscribe(receiver: NJSEventReceiver);
}
/**Class representing an event publisher */
declare class NJSEventPublisher
{
    /**
     *Get event bus through which publisher broadcast its events
     *@return EventBus object
     */
    declare function getEventBus(): NJSEventBus;
    /**
     *Broadcast an event through eventbus (to all subscribed receivers to this EventBus)
     *@param event, Event object
     */
    declare function post(event: NJSEvent);
    /**
     *Same as post method but with an sticky event
     *@param event, Event object
     *@param tag, 32 bits integer, tag of sticky event
     */
    declare function postSticky(event: NJSEvent, tag: number);
    /**
     *Relay an event to another EventBus (other than EventPublisher's event bus)
     *@param bus, EventBus object, through which we want to broadcast EventPublisher's event to EventPublisher's receiver
     */
    declare function relay(bus: NJSEventBus);
    /**
     *Create a new instance of EventPublisher class
     *@param context, executionContext object, context in which event publisher broadcast its events
     */
    static declare function newInstance(context: NJSExecutionContext): NJSEventPublisher;
}
/**Class of synchronization status constants */
declare class NJSSynchronizationStatus
{
}
declare class NJSDerivationPath
{
    /** Get the number of element in this path. */
    declare function getDepth(): number;
    /** Get the child num at the given index in the path. */
    declare function getChildNum(index: number): number;
    /**
     * Get the child num at the given index in the path. If the child num is hardened, returns it
     * without the hardened marker bit.
     */
    declare function getUnhardenedChildNum(index: number): number;
    /** Return true if the given index in the path is an hardened child num. */
    declare function isHardened(index: number): boolean;
    /** Serialize the given path to a human readable string like "44'/0'/0'/0/0" */
    declare function toString(): string;
    /**
     * Return a derivation path without the last element, e.g. the parent of "44'/0'/0'/0/0" is
     * "44'/0'/0'/0"
     */
    declare function getParent(): NJSDerivationPath;
    /** Return an array where which item is a child num of the path. */
    declare function toArray(): Array<number>;
    static declare function parse(path: string): NJSDerivationPath;
}
/**TODO */
declare class NJSTrustIndicator
{
    declare function getTrustWeight(): number;
    declare function getTrustLevel(): TrustLevel;
    declare function getConflictingOperationUids(): Array<string>;
    declare function getOrigin(): string;
}
/**Class representing an operation */
declare class NJSOperation
{
    /**
     *Get id's operation
     *@return string
     */
    declare function getUid(): string;
    /**
     *Get account's index in user's wallet
     *@return 32 bits integer
     */
    declare function getAccountIndex(): number;
    /**
     *Get type of operation
     *@return OperationType object (for more details refer to OperationType)
     */
    declare function getOperationType(): OperationType;
    /**
     *Return date on which operation was issued
     *@return date object
     */
    declare function getDate(): Date;
    /**
     *Get senders of operation
     *@return List of string, list of all senders
     */
    declare function getSenders(): Array<string>;
    /**
     *Get recipients of operation
     *@return List of string, list of all recipients
     */
    declare function getRecipients(): Array<string>;
    /**
     *Get amount of operation
     *@return Amount object
     */
    declare function getAmount(): NJSAmount;
    /**
     *Get fees of operation
     *@return Optional Amount object
     */
    declare function getFees(): ?NJSAmount;
    /**
     *Get preferences of operation
     *@return Prefences object
     */
    declare function getPreferences(): NJSPreferences;
    /**
     *Get trust indicator of operation
     *@return TrustIndicator object
     */
    declare function getTrust(): NJSTrustIndicator;
    /**
     *Get block height on which operation was included
     *@return Optional 64 bits integer, height of block in which operation was validated
     */
    declare function getBlockHeight(): ?number;
    /**
     *Convert operation as Bitcoin operation
     *@return BitcoinLikeOperation object
     */
    declare function asBitcoinLikeOperation(): NJSBitcoinLikeOperation;
    declare function isInstanceOfBitcoinLikeOperation(): boolean;
    /**
     *Same as asBitcoinLikeOperation for ethereum
     *# asEthereumLikeOperation(): Callback<EthereumLikeOperation>;
     *Same as isInstanceOfBitcoinLikeOperation for ethereum
     */
    declare function isInstanceOfEthereumLikeOperation(): boolean;
    /**
     *Same as asBitcoinLikeOperation for ripple
     *# asRippleLikeOperation(): Callback<RippleLikeOperation>;
     *Same as isInstanceOfBitcoinLikeOperation for ripple
     */
    declare function isInstanceOfRippleLikeOperation(): boolean;
    /**
     *Tells if the operation is complete
     *@return boolean
     */
    declare function isComplete(): boolean;
    /**
     *Get type of wallet from which operation was issued
     *@return WalletType object
     */
    declare function getWalletType(): WalletType;
    declare function getCurrency(): Currency;
}
/**TODO */
declare class NJSQueryFilter
{
    static declare function accountEq(accountUid: string): NJSQueryFilter;
    static declare function accountNeq(accountUid: string): NJSQueryFilter;
    static declare function dateLte(time: Date): NJSQueryFilter;
    static declare function dateLt(time: Date): NJSQueryFilter;
    static declare function dateGt(time: Date): NJSQueryFilter;
    static declare function dateGte(time: Date): NJSQueryFilter;
    static declare function dateEq(time: Date): NJSQueryFilter;
    static declare function dateNeq(time: Date): NJSQueryFilter;
    static declare function containsRecipient(recipientAddress: string): NJSQueryFilter;
    static declare function containsSender(senderAddress: string): NJSQueryFilter;
    static declare function currencyEq(currencyName: string): NJSQueryFilter;
    static declare function operationUidEq(operationUid: string): NJSQueryFilter;
    static declare function operationUidNeq(operationUid: string): NJSQueryFilter;
    static declare function trustEq(trust: TrustLevel): NJSQueryFilter;
    static declare function trustNeq(trust: TrustLevel): NJSQueryFilter;
    static declare function feesEq(amount: NJSAmount): NJSQueryFilter;
    static declare function feesNeq(amount: NJSAmount): NJSQueryFilter;
    static declare function feesGte(amount: NJSAmount): NJSQueryFilter;
    static declare function feesGt(amount: NJSAmount): NJSQueryFilter;
    static declare function feesLte(amount: NJSAmount): NJSQueryFilter;
    static declare function feesLt(amount: NJSAmount): NJSQueryFilter;
    static declare function amountEq(amount: NJSAmount): NJSQueryFilter;
    static declare function amountNeq(amount: NJSAmount): NJSQueryFilter;
    static declare function amountGte(amount: NJSAmount): NJSQueryFilter;
    static declare function amountGt(amount: NJSAmount): NJSQueryFilter;
    static declare function amountLte(amount: NJSAmount): NJSQueryFilter;
    static declare function amountLt(amount: NJSAmount): NJSQueryFilter;
    static declare function blockHeightEq(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightNeq(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightGte(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightGt(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightLte(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightLt(blockHeight: number): NJSQueryFilter;
    static declare function blockHeightIsNull(): NJSQueryFilter;
    static declare function operationTypeEq(operationType: OperationType): NJSQueryFilter;
    static declare function operationTypeNeq(operationType: OperationType): NJSQueryFilter;
    declare function op_and(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_or(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_and_not(filter: NJSQueryFilter): NJSQueryFilter;
    declare function op_or_not(filter: NJSQueryFilter): NJSQueryFilter;
}
/**Class respresenting a query for a set of operations */
declare class NJSOperationQuery
{
    /**
     *Apply given order to query's operation
     *@param key, OperationOrderKey object which defines order
     *@param descending, bool
     *@return OperationQuery object, new ordered operation
     */
    declare function addOrder(key: OperationOrderKey, descending: boolean): NJSOperationQuery;
    /**
     *Get applied filter on operation query
     *@return QueryFilter object
     */
    declare function filter(): NJSQueryFilter;
    /**
     *Add offset to the operation query
     *@param from, 64 bits integer
     */
    declare function offset(from: number): NJSOperationQuery;
    /**
     *Add limit to the operation query results
     *@param count, 64 bits integer
     */
    declare function limit(count: number): NJSOperationQuery;
    /**
     *TODO
     *Complete the operation query
     */
    declare function complete(): NJSOperationQuery;
    /**TODO */
    declare function partial(): NJSOperationQuery;
    /**
     *Execute query to retrieve operations
     *@param callback, if execute method succeed, ListCallback object returning a List of Operation objects
     */
    declare function execute(callback: NJSOperationListCallback);
}
/**
 *Callback triggered by main completed task,
 *returns optional result as list of template type T
 */
declare class NJSOperationListCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSOperation>, error: ?Error);
}
declare class NJSAddress
{
    /**
     * Gets an optional derivation path (if the address is owned by an account)
     * @return The derivation path of the address
     */
    declare function getDerivationPath(): ?string;
    /**
     * Serialize the address to a string. The serialization method depends of the underlying currency and
     * format (Base58, Bech32, Ethereum...)
     */
    declare function toString(): string;
    declare function asBitcoinLikeAddress(): ?NJSBitcoinLikeAddress;
    declare function isInstanceOfBitcoinLikeAddress(): boolean;
    declare function getCurrency(): Currency;
    /**
     * Attempt to parse a string address. If the address can be parse return it otherwise return a NONE
     * (depending on you host this may be a null, nil, None...)
     * @param address The string to parse
     * @param currency The currency used to parse the address
     * @return If successful returns the address object otherwise null.
     */
    static declare function parse(address: string, currency: Currency): ?NJSAddress;
    /**
     * Checks if the given string formatted address is valid or not.
     * @param address The string to parse
     * @param currency The currency used to parse the address
     * @return If successful returns true, false otherwise.
     */
    static declare function isValid(address: string, currency: Currency): boolean;
}
/**Class representing an account */
declare class NJSAccount
{
    /**
     *Get index of account in user's wallet
     *32 bits integer
     */
    declare function getIndex(): number;
    /**TODO */
    declare function queryOperations(): NJSOperationQuery;
    /**
     *Get balance of account
     *@param callback, if getBalacne, Callback returning an Amount object which represents account's balance
     */
    declare function getBalance(callback: NJSAmountCallback);
    /**
     *Get balance of account at a precise interval with a certain granularity
     *@param start, lower bound of search range
     *@param end, upper bound of search range
     *@param precision, granularity at which we want results
     *@param callback, ListCallback returning a list of Amount object which represents account's balance
     */
    declare function getBalanceHistory(start: string, end: string, period: TimePeriod, callback: NJSAmountListCallback);
    /**
     *Get synchronization status of account
     *@return bool
     */
    declare function isSynchronizing(): boolean;
    /**
     *Start synchronization of account
     *@return EventBus, handler will be notified of synchronization outcome
     */
    declare function synchronize(): NJSEventBus;
    /**
     *Return account's preferences
     *@return Preferences object
     */
    declare function getPreferences(): NJSPreferences;
    /**
     *Return account's logger which provides all needed (e.g. database) logs
     *@return Logger Object
     */
    declare function getLogger(): NJSLogger;
    /**
     *Return preferences of specific operation
     *@param uid, string of operation id
     *@return Preferences
     *Return operation for a specific operation
     *@param uid, string of operation id
     */
    declare function getOperationPreferences(uid: string): NJSPreferences;
    declare function asBitcoinLikeAccount(): NJSBitcoinLikeAccount;
    /**
     * asEthereumLikeAccount(): Callback<EthereumLikeAccount>;
     * asRippleLikeAccount(): Callback<RippleLikeAccount>;
     *Check if account is a Bitcoin one
     *@return bool
     */
    declare function isInstanceOfBitcoinLikeAccount(): boolean;
    /**
     *Check if account is an Ethereum one
     *@return bool
     */
    declare function isInstanceOfEthereumLikeAccount(): boolean;
    /**
     *Check if account is a Ripple one
     *@return bool
     */
    declare function isInstanceOfRippleLikeAccount(): boolean;
    /**TODO */
    declare function getFreshPublicAddresses(callback: NJSAddressListCallback);
    /**
     *Get type of wallet to which account belongs
     *@return WalletType object
     */
    declare function getWalletType(): WalletType;
    /**
     *Get event bus through which account is notified on synchronization status
     *@return EventBus object
     */
    declare function getEventBus(): NJSEventBus;
    /**Start observing blockchain on which account synchronizes and send/receive transactions */
    declare function startBlockchainObservation();
    /**Stop observing blockchain */
    declare function stopBlockchainObservation();
    /**
     *Get account's observation status
     *@return boolean
     */
    declare function isObservingBlockchain(): boolean;
    /**
     *Get Last block of blockchain on which account operates
     *@param callback, Callback returning, if getLastBlock succeeds, a Block object
     */
    declare function getLastBlock(callback: NJSBlockCallback);
    /** Get the key used to generate the account */
    declare function getRestoreKey(): string;
    /**
     *Erase data (in user's DB) relative to wallet since given date
     *@param date, start date of data deletion
     */
    declare function eraseDataSince(date: Date, callback: NJSErrorCodeCallback);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSAmountCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSAmount, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result as list of template type T
 */
declare class NJSAmountListCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSAmount>, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result as list of template type T
 */
declare class NJSAddressListCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSAddress>, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSBlockCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Block, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSErrorCodeCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?ErrorCode, error: ?Error);
}
/**Class representing a wallet */
declare class NJSWallet
{
    /**
     *Get name of wallet
     *@return string
     */
    declare function getName(): string;
    /**
     *Get account with specific index
     *@param index, 32 bits integer, index of account in wallet
     *@param callback, Callback returning, if getAccount succeed, an Account object with given index
     */
    declare function getAccount(index: number, callback: NJSAccountCallback);
    /**
     *Get number of accounts instanciated under wallet
     *@param callback, Callback returning, if getAccountCount succeed, a 32 bits integer representing number of accounts
     */
    declare function getAccountCount(callback: NJSI32Callback);
    /**
     *Get list of accounts instanciated under wallet in a given range
     *@param offset, 32 bits integer from which we retrieve accounts
     *@param count, 32 bits integer, number of accounts to retrieve
     *@param callback, ListCallback returning, if getAccounts succeed, list of Accounts object
     */
    declare function getAccounts(offset: number, count: number, callback: NJSAccountListCallback);
    /**
     *Get index of next account to create
     *@return callback, Callback returning a 32 bits integer
     */
    declare function getNextAccountIndex(callback: NJSI32Callback);
    /**
     *Return event bus through which wallet synchronizes it's accounts and interact with blockchain
     *@return EventBus object
     */
    declare function getEventBus(): NJSEventBus;
    /**
     *Return synchronization status wallet, true if at least one of accounts is synchronizing
     *@return bool
     */
    declare function isSynchronizing(): boolean;
    /**
     *Start synchronization of all accounts under wallet
     *@return EventBus object through which wallet get notified of account's synchronization status
     */
    declare function synchronize(): NJSEventBus;
    /**
     *Get wallet preferences
     *@return Preferences object
     */
    declare function getPreferences(): NJSPreferences;
    /**
     *Return account's logger which provides all needed (e.g. database) logs
     *@return Logger Object
     */
    declare function getLogger(): NJSLogger;
    /**
     *Get preferences of specific account
     *@param index, 32 bits integer, account's index
     *@return Preferences object
     */
    declare function getAccountPreferences(index: number): NJSPreferences;
    /**
     * asBitcoinLikeWallet(): Callback<BitcoinLikeWallet>;
     * asEthereumLikeWallet(): Callback<EthereumLikeWallet>;
     * asRippleLikeWallet(): Callback<RippleLikeWallet>;
     *Convert wallet to a Bitcoin one
     *@return BitcoinWallet object
     */
    declare function asBitcoinLikeWallet(): NJSBitcoinLikeWallet;
    /**
     *Get currency of wallet
     *@return Currency object
     */
    declare function getCurrency(): Currency;
    /**
     *Know if wallet is a Bitcoin one
     *@return bool
     */
    declare function isInstanceOfBitcoinLikeWallet(): boolean;
    /**
     *Know if wallet is a Ethereum one
     *@return bool
     */
    declare function isInstanceOfEthereumLikeWallet(): boolean;
    /**
     *Know if wallet is a Ripple one
     *@return bool
     */
    declare function isInstanceOfRippleLikeWallet(): boolean;
    /**
     *Get wallet type
     *@return WalletType object
     */
    declare function getWalletType(): WalletType;
    /**
     *Get last block of blockchain the wallet operates on
     *@param callback, Callback returning a Block object
     */
    declare function getLastBlock(callback: NJSBlockCallback);
    /**
     *Return infos about the creation of specific account
     *@param accountIndex, 32 bits account, index of account in wallet
     *@param callback, Callback returning an AccountCreationInfo
     */
    declare function getAccountCreationInfo(accountIndex: number, callback: NJSAccountCreationInfoCallback);
    /**TODO */
    declare function getExtendedKeyAccountCreationInfo(accountIndex: number, callback: NJSExtendedKeyAccountCreationInfoCallback);
    /**
     *Return infos about the next created account
     *@param callback, Callback returning an AccountCreationInfo
     */
    declare function getNextAccountCreationInfo(callback: NJSAccountCreationInfoCallback);
    /**TODO */
    declare function getNextExtendedKeyAccountCreationInfo(callback: NJSExtendedKeyAccountCreationInfoCallback);
    /**
     *Get account from given account creation infos
     *@param accountCreationInfo, AccountCreationInfo object
     *@param callback, Callback returning an Account object with given creation infos
     */
    declare function newAccountWithInfo(accountCreationInfo: AccountCreationInfo, callback: NJSAccountCallback);
    /**TODO */
    declare function newAccountWithExtendedKeyInfo(extendedKeyAccountCreationInfo: ExtendedKeyAccountCreationInfo, callback: NJSAccountCallback);
    /**
     *Erase data (in user's DB) relative to wallet since given date
     *@param date, start date of data deletion
     */
    declare function eraseDataSince(date: Date, callback: NJSErrorCodeCallback);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSAccountCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSAccount, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSI32Callback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?number, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result as list of template type T
 */
declare class NJSAccountListCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSAccount>, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSAccountCreationInfoCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?AccountCreationInfo, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSExtendedKeyAccountCreationInfoCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?ExtendedKeyAccountCreationInfo, error: ?Error);
}
/**
 *Class representing an object that holds references to different types of objects,
 *those references are appended dynamically in an array like structure and can be retrieved by their index
 */
declare class NJSDynamicArray
{
    /**
     *Get count of stored references
     *@return 64 bits integer
     */
    declare function size(): number;
    /**
     *Push a 32 bits integer
     *@param value, 32 bits integer
     *@return DynamicArray with value stored in it
     */
    declare function pushInt(value: number): NJSDynamicArray;
    /**
     *Push a 64 bits integer
     *@param value, 64 bits integer
     *@return DynamicArray with value stored in it
     */
    declare function pushLong(value: number): NJSDynamicArray;
    /**
     *Push a string
     *@param value, string
     *@return DynamicArray with value stored in it
     */
    declare function pushString(value: string): NJSDynamicArray;
    /**
     *Push a double
     *@param value, double
     *@return DynamicArray with value stored in it
     */
    declare function pushDouble(value: number): NJSDynamicArray;
    /**
     *Push a binary
     *@param value, binary
     *@return DynamicArray with value stored in it
     */
    declare function pushData(value: Object): NJSDynamicArray;
    /**
     *Push a bool
     *@param value, bool
     *@return DynamicArray with value stored in it
     */
    declare function pushBoolean(value: boolean): NJSDynamicArray;
    /**
     *Push a DynamicObject object
     *@param value, DynamicObject
     *@return DynamicArray with value stored in it
     */
    declare function pushObject(value: NJSDynamicObject): NJSDynamicArray;
    /**
     *Push a DynamicArray object
     *@param value, DynamicArray
     *@return DynamicArray with value stored in it
     */
    declare function pushArray(value: NJSDynamicArray): NJSDynamicArray;
    /**
     *Get string at a given index
     *@param index, 64 bits integer
     *@return Optional string
     */
    declare function getString(index: number): ?string;
    /**
     *Get 32 bits integer at a given index
     *@param index, 64 bits integer
     *@return Optional 32 bits integer
     */
    declare function getInt(index: number): ?number;
    /**
     *Get 64 bits integer at a given index
     *@param index, 64 bits integer
     *@return Optional 64 bits integer
     */
    declare function getLong(index: number): ?number;
    /**
     *Get double at a given index
     *@param index, 64 bits integer
     *@return Optional double
     */
    declare function getDouble(index: number): ?number;
    /**
     *Get binary at a given index
     *@param index, 64 bits integer
     *@return Optional binary
     */
    declare function getData(index: number): ?Object;
    /**
     *Get bool at a given index
     *@param index, 64 bits integer
     *@return Optional bool
     */
    declare function getBoolean(index: number): ?boolean;
    /**
     *Get DynamicObject object at a given index
     *@param index, 64 bits integer
     *@return Optional DynamicObject
     */
    declare function getObject(index: number): ?NJSDynamicObject;
    /**
     *Get DynamicArray object at a given index
     *@param index, 64 bits integer
     *@return Optional DynamicArray
     */
    declare function getArray(index: number): ?NJSDynamicArray;
    /**
     *Concatenate current DynamicArray with another one
     *@param array, DynamicArray object to concatenate with
     *@return DynamicArray object, concatenated DynamicArray
     */
    declare function concat(array: NJSDynamicArray): NJSDynamicArray;
    /**
     *Get type of value stored at a given index
     *@param index, 64 bits integer
     *@return Optional DynamicType enum entry
     */
    declare function getType(index: number): ?DynamicType;
    /**
     *Delete value stored at given index
     *@param index, 64 bits integer
     *@return bool, true if deletion succeeded
     */
    declare function remove(index: number): boolean;
    /**
     *Dump whole object's content as string
     *@return string
     */
    declare function dump(): string;
    /**
     *Serialize whole object to a binary
     *@return binary
     */
    declare function serialize(): Object;
    /**
     *Get readonly status of object
     *@param bool
     */
    declare function isReadOnly(): boolean;
    /**
     *Create a new instance of DynamicArray class
     *@return DynamicArray instance
     */
    static declare function newInstance(): NJSDynamicArray;
    /**
     *Parse a binary to a DynamicArray
     *@param serialized, binary to parse
     *@return Optional DynamicArray
     */
    static declare function load(serialized: Object): ?NJSDynamicArray;
}
/**
 *Class representing an object that stores values of different types of objects,
 *those values are appended dynamically in a map like structure with a given key through which they can be retreived
 */
declare class NJSDynamicObject
{
    /**
     *Store a string with a given key
     *@param key, string, key to access stored value
     *@param value, string
     *@return DynamicObject object with value stored in it
     */
    declare function putString(key: string, value: string): NJSDynamicObject;
    /**
     *Store a 32 bits integer with a given key
     *@param key, string, key to access stored value
     *@param value, 32 bits integer
     *@return DynamicObject object with value stored in it
     */
    declare function putInt(key: string, value: number): NJSDynamicObject;
    /**
     *Store a 64 bits integer with a given key
     *@param key, string, key to access stored value
     *@param value, 64 bits integer
     *@return DynamicObject object with value stored in it
     */
    declare function putLong(key: string, value: number): NJSDynamicObject;
    /**
     *Store a double with a given key
     *@param key, string, key to access stored value
     *@param value, double
     *@return DynamicObject object with value stored in it
     */
    declare function putDouble(key: string, value: number): NJSDynamicObject;
    /**
     *Store a binary integer with a given key
     *@param key, string, key to access stored value
     *@param value, binary
     *@return DynamicObject object with value stored in it
     */
    declare function putData(key: string, value: Object): NJSDynamicObject;
    /**
     *Store a boolean integer with a given key
     *@param key, string, key to access stored value
     *@param value, bool
     *@return DynamicObject object with value stored in it
     */
    declare function putBoolean(key: string, value: boolean): NJSDynamicObject;
    /**
     *Store another DynamicObject object with a given key
     *@param key, string, key to access stored value
     *@return DynamicObject object with value stored in it
     */
    declare function putObject(key: string, value: NJSDynamicObject): NJSDynamicObject;
    /**
     *Store a DynamicArray object with a given key
     *@param key, string, key to access stored reference
     *@return DynamicArray object with value stored in it
     */
    declare function putArray(key: string, value: NJSDynamicArray): NJSDynamicObject;
    /**
     *Get, if exists, stored string having a specific key
     *@param key, string, key of string to look for
     *@return Optional string
     */
    declare function getString(key: string): ?string;
    /**
     *Get, if exists, stored 32 bits integer having a specific key
     *@param key, string, key of 32 bits integer to look for
     *@return Optional 32 bits integer
     */
    declare function getInt(key: string): ?number;
    /**
     *Get, if exists, stored 64 bits integer having a specific key
     *@param key, string, key of 64 bits integer to look for
     *@return Optional 64 bits integer
     */
    declare function getLong(key: string): ?number;
    /**
     *Get, if exists, stored double having a specific key
     *@param key, string, key of double to look for
     *@return Optional double
     */
    declare function getDouble(key: string): ?number;
    /**
     *Get, if exists, stored binary having a specific key
     *@param key, string, key of binary to look for
     *@return Optional binary
     */
    declare function getData(key: string): ?Object;
    /**
     *Get, if exists, stored bool having a specific key
     *@param key, string, key of bool to look for
     *@return Optional bool
     */
    declare function getBoolean(key: string): ?boolean;
    /**
     *Get, if exists, stored DynamicObject having a specific key
     *@param key, string, key of DynamicObject to look for
     *@return Optional DynamicObject
     */
    declare function getObject(key: string): ?NJSDynamicObject;
    /**
     *Get, if exists, stored DynamicArray having a specific key
     *@param key, string, key of DynamicArray to look for
     *@return Optional DynamicArray
     */
    declare function getArray(key: string): ?NJSDynamicArray;
    /**
     *Check if a key was used to store a value
     *@param key, string, key to look for
     *@return bool
     */
    declare function contains(key: string): boolean;
    /**
     *Delete key and value stored with it
     *@param key, string, key to look for
     *@return bool, true if key exists and deletion succeeded, false otherwise
     */
    declare function remove(key: string): boolean;
    /**
     *Get list of keys
     *@return list of string, list all stored keys
     */
    declare function getKeys(): Array<string>;
    /**
     *Get type of object stored with specific key
     *@param key, string, key to look for
     *@return Optional DynamicType enum entry
     */
    declare function getType(key: string): ?DynamicType;
    /**
     *Dump whole object's content as string
     *@return string
     */
    declare function dump(): string;
    /**
     *Serialize whole object to a binary
     *@return binary
     */
    declare function serialize(): Object;
    /**
     *Get readonly status of object
     *@param bool
     */
    declare function isReadOnly(): boolean;
    /**
     *Get count of stored references
     *@return 64 bits integer
     */
    declare function size(): number;
    /**
     *Create a new instance of DynamicObject class
     *@return DynamicObject instance
     */
    static declare function newInstance(): NJSDynamicObject;
    /**
     *Parse a binary to a DynamicObject
     *@param serialized, binary to parse
     *@return Optional DynamicObject
     */
    static declare function load(serialized: Object): ?NJSDynamicObject;
}
/**TODO */
declare class NJSBlockchainExplorerEngines
{
}
declare class NJSBlockchainObserverEngines
{
}
declare class NJSKeychainEngines
{
}
/**Class of constants representing the engines to rely on for synchronization */
declare class NJSSynchronizerEngines
{
}
/**TODO */
declare class NJSSynchronizationEngines
{
}
/**TODO */
declare class NJSConfigurationDefaults
{
}
declare class NJSConfiguration
{
}
/**TODO */
declare class NJSPoolConfiguration
{
}
/**Class representing a database */
declare class NJSDatabaseBackend
{
    /**
     *Set database's user name
     *@param username, string
     *@return DatabaseBackend object, databse with user name set
     */
    declare function setUsername(username: string): NJSDatabaseBackend;
    /**
     *Set database's password
     *@param password, string
     *@return DatabaseBackend object, database with password set
     */
    declare function setPassword(pwd: string): NJSDatabaseBackend;
    /**
     *Set database's host which storing database
     *@param host, string
     *@return DatabaseBackend object, database with host set
     */
    declare function setHost(host: string): NJSDatabaseBackend;
    /**
     *Set database's host's address
     *@param hostAddr, string, host's address
     *@return DatabaseBackend object, database with host's address set
     */
    declare function setHostAddr(hostAddr: string): NJSDatabaseBackend;
    /**
     *Set database's port on which it connects to host
     *@param port, string
     *@return DatabaseBackend object, database with port set
     */
    declare function setPort(port: string): NJSDatabaseBackend;
    /**
     *Set database's specific options
     *@param opts, string
     *@return DatabaseBackend object, database with options set
     */
    declare function setOptions(opts: string): NJSDatabaseBackend;
    /**
     *Set database's mode (SSL) of security interaction of type databse/server
     *@param mode, string
     *@return DatabaseBackend object, database with mode set
     */
    declare function setSslMode(mode: string): NJSDatabaseBackend;
    /**
     *Set database's Kerberos name used to secure (authentication) user/databse interaction
     *@param name, string
     *@return DatabaseBackend object, database with Kerberos name set
     */
    declare function setKerberosName(name: string): NJSDatabaseBackend;
    /**TODO */
    declare function setService(service: string): NJSDatabaseBackend;
    declare function setConnectionPoolSize(size: number): NJSDatabaseBackend;
    declare function enableQueryLogging(enable: boolean): NJSDatabaseBackend;
    /**
     *Return database's name
     *@return string
     */
    declare function getUsername(): string;
    /**
     *Return database's password
     *@return string
     */
    declare function getPassword(): string;
    /**
     *Return database's host
     *@return string
     */
    declare function getHost(): string;
    /**
     *Return database's host's address
     *@return string
     */
    declare function getHostAddr(): string;
    /**
     *Return database's port
     *@return string
     */
    declare function getPort(): string;
    /**
     *Return database's options
     *@return string
     */
    declare function getOptions(): string;
    /**
     *Return database's SSL mode
     *@return string
     */
    declare function getSslMode(): string;
    /**
     *Return database's Kerberos name
     *@return string
     */
    declare function getKerberosName(): string;
    /**TODO */
    declare function getService(): string;
    declare function getConnectionPoolSize(): number;
    declare function isLoggingEnabled(): boolean;
    /**
     *Create an instance of SQLite3 database
     *@return DatabaseBackend object
     */
    static declare function getSqlite3Backend(): NJSDatabaseBackend;
    /**
     *Create an instance of PostgreSQL database
     *@return DatabaseBackend object
     */
    static declare function getPostgreSQLBackend(): NJSDatabaseBackend;
}
/** Class to generate random numbers */
declare class NJSRandomNumberGenerator
{
    /**
     * Generates random bytes.
     * @params size number of bytes to generate
     * @return 'size' random bytes
     */
    declare function getRandomBytes(size: number): Object;
    /**
     * Generates random 32 bits integer.
     * @return random 32 bits integer
     */
    declare function getRandomInt(): number;
    /**
     * Generates random 64 bits integer.
     * @return random 64 bits integer
     */
    declare function getRandomLong(): number;
    /**
     * Generates random byte.
     * @return random byte
     */
    declare function getRandomByte(): number;
}
declare class NJSEthereumPublicKeyProvider
{
}
declare class NJSGetEthreumLikeWalletCallback
{
    declare function onSuccess(wallet: NJSEthereumLikeWallet, isCreated: boolean);
    declare function onError(error: Error);
}
declare class NJSEthereumLikeWallet
{
}
declare class NJSBitcoinLikeScriptChunk
{
    declare function isOperator(): boolean;
    declare function isPushedData(): boolean;
    declare function getOperator(): ?BitcoinLikeOperator;
    declare function getPushedData(): ?Object;
    declare function next(): NJSBitcoinLikeScriptChunk;
    declare function hasNext(): boolean;
}
declare class NJSBitcoinLikeScript
{
    declare function head(): NJSBitcoinLikeScriptChunk;
    declare function toString(): string;
    static declare function parse(data: Object): NJSBitcoinLikeScript;
}
/** Helper class for manipulating Bitcoin like addresses */
declare class NJSBitcoinLikeAddress
{
    /**
     * Gets the version of the address (P2SH or P2PKH)
     * @return The version of the address
     */
    declare function getVersion(): Object;
    /**
     * Gets the raw hash160 of the public key
     * @return The 20 bytes of the public key hash160
     */
    declare function getHash160(): Object;
    /**
     * Gets the network parameters used for serializing the address
     * @return The network parameters of the address
     */
    declare function getNetworkParameters(): BitcoinLikeNetworkParameters;
    /**
     * Serializes the hash160 into a Base58 encoded address (with checksum)
     * @return The Base58 serialization
     */
    declare function toBase58(): string;
    /**
     * Serializes the hash160 to a payment uri (i.e bitcoin:16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM)
     * @return A payment uri to this address
     * toPaymentUri(): string;
     * Checks if the given address is a P2SH address
     * @return True if the version byte matches the P2SH byte version of the address network parameters
     */
    declare function isP2SH(): boolean;
    /**
     * Checks if the given address is a P2PKH address
     * @return True if the version byte matches the P2PKH byte version of the address network parameters
     */
    declare function isP2PKH(): boolean;
}
declare class NJSBitcoinLikeExtendedPublicKey
{
    declare function derive(path: string): NJSBitcoinLikeAddress;
    declare function derivePublicKey(path: string): Object;
    declare function deriveHash160(path: string): Object;
    declare function toBase58(): string;
    declare function getRootPath(): string;
}
/**Class representing amount of transaction, output, inputs ... */
declare class NJSAmount
{
    /**
     *Get amount as a BitInt
     *@return BitInt
     */
    declare function toBigInt(): NJSBigInt;
    /**
     *Get currency in which amount was computed
     *@return Currency object
     */
    declare function getCurrency(): Currency;
    /**
     *Get currency unit in which amount was computed
     *@return CurrencyUnit object
     */
    declare function getUnit(): CurrencyUnit;
    /**
     *Convert amount in another currency unit
     *@param CurrencyUnit object, target currency unit
     *@return Amount object, amount in target currency unit
     */
    declare function toUnit(unit: CurrencyUnit): NJSAmount;
    /**TODO */
    declare function toMagnitude(magnitude: number): NJSAmount;
    /**
     *Get amount as string
     *@return string
     */
    declare function toString(): string;
    /**
     *Get amount as long
     *@reutrn 64 bits integer
     */
    declare function toLong(): number;
    /**
     *Get amount as double
     *@return double
     */
    declare function toDouble(): number;
    /**TODO */
    declare function format(locale: Locale, rules: ?FormatRules): string;
    static declare function fromHex(currency: Currency, hex: string): NJSAmount;
    static declare function fromLong(currency: Currency, value: number): NJSAmount;
}
/**
 * Interface for accessing and modifying custom preferences. Preferences are key - value data which will be persisted to
 * the filesystem. They can be local or stored with the Ledger API backend (encrypted by a user secret). This can be used to
 * attach application data to the libledger-core modules (i.e. a wallet pool, a wallet, an account, an operation). This interface
 * is highly inspired by Android SharedPreferences.
 */
declare class NJSPreferences
{
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getString(key: string, fallbackValue: string): string;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getInt(key: string, fallbackValue: number): number;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getLong(key: string, fallbackValue: number): number;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getBoolean(key: string, fallbackValue: boolean): boolean;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getStringArray(key: string, fallbackValue: Array<string>): Array<string>;
    /**
     * Retrieves the value associated with the given key or fallback to the default value.
     * @return The data associated with the key or fallbackValue.
     */
    declare function getData(key: string, fallbackValue: Object): Object;
    /**
     * Checks whether the Preferences contains the given key.
     * @return true the preferences contains the key, false otherwise.
     */
    declare function contains(key: string): boolean;
    /**
     * Get a preferences editor in order to add/modify/remove data.
     * @return An interface for editting preferences.
     */
    declare function edit(): NJSPreferencesEditor;
}
/** Interface for editting Preferences. All changes to the editor are persisted to the disk only when comitted. */
declare class NJSPreferencesEditor
{
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putString(key: string, value: string): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putInt(key: string, value: number): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putLong(key: string, value: number): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putBoolean(key: string, value: boolean): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putStringArray(key: string, value: Array<string>): NJSPreferencesEditor;
    /**
     * Sets the value to the given key in the Preferences.
     * @param key The data key.
     * @param value The value to store
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function putData(key: string, value: Object): NJSPreferencesEditor;
    /**
     * Removes the data associated with the given key.
     * @param key The key to remove from the Preferences
     * @return The reference of self in order to chain the call to the editor.
     */
    declare function remove(key: string): NJSPreferencesEditor;
    /** Persists the changes to the Preferences. */
    declare function commit();
}
/**Class of constants to set Bitcoin like wallet configurations */
declare class NJSBitcoinLikeWalletConfiguration
{
}
/**Class representing Bitcoin inputs */
declare class NJSBitcoinLikeInput
{
    /** Returns the address of the input (if an address can be computed) */
    declare function getAddress(): ?string;
    /**
     * Returns the public associated with the address. This value can be NULL if you are building a transaction with an
     * address which does not belong to your wallet.
     */
    declare function getPublicKeys(): Array<Object>;
    /** Returns the derivation path of this input if the address is owned by the wallet */
    declare function getDerivationPath(): Array<NJSDerivationPath>;
    /**
     * Returns the value of the amount. Depending on the backend this value may not exist if the input is not owned by
     * the wallet.
     */
    declare function getValue(): ?NJSAmount;
    /**
     * Get the transaction hash of the output spent by this input. The result can be NULL if the output is not owned by
     * the wallet
     */
    declare function getPreviousTxHash(): ?string;
    /**
     * Get the index at which the output is located in the transaction output spent by this input. The result can be
     * NULL if the input does not belong to the wallet
     *Check whether input
     *@return Boolean, true if input belongs to coinbase transaction (reward for mining a block)
     */
    declare function isCoinbase(): boolean;
    /**
     *Stored data cointained in coinbase
     *@return Optional String
     */
    declare function getCoinbase(): ?string;
    /**
     *Get output index, it identifies which UTXO from tht transaction to spend
     *@return Optional 32 bits integer, index of previous transaction
     */
    declare function getPreviousOutputIndex(): ?number;
    /**
     * Retrieve the output spent by this input. Depending on the implementation this method may
     * use a lock to fetch data from a database. Therefore it may have poor performance, use with
     * caution.
     * @return The output spent by this input.
     */
    declare function getPreviousOuput(): NJSBitcoinLikeOutput;
    /** Get ScriptSig of this input. The scriptsig is the first half of a script necessary to spend a previous output. */
    declare function getScriptSig(): Object;
    /** Parse the script sig to a [[BitcoinLikeScript]] */
    declare function parseScriptSig(): NJSBitcoinLikeScript;
    /**
     * Set the ScriptS to the given value
     * @param scriptSig The ScriptSig to use for this input
     */
    declare function setScriptSig(scriptSig: Object);
    /** Push data to the end of the current ScriptSig */
    declare function pushToScriptSig(data: Object);
    /** Set the sequence number of this input */
    declare function setSequence(sequence: number);
    /** Get the sequence number of this input */
    declare function getSequence(): number;
    declare function getPreviousTransaction(callback: NJSBinaryCallback);
    /** Easy way to set the P2PKH script signature. Shorthand for input.pushToScriptSig(input.getPublicKeys()[0], signature) */
    declare function setP2PKHSigScript(signature: Object);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSBinaryCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Object, error: ?Error);
}
/**Class representing Bitcoin outputs */
declare class NJSBitcoinLikeOutput
{
    /**
     *Get transaction hash in which output was 'created'
     *@return String, transaction hash containing output
     */
    declare function getTransactionHash(): string;
    /**
     *Get index of output in list of all outputs contained in same transaction
     *@return 32 bits integer, index of output
     */
    declare function getOutputIndex(): number;
    /**
     *Get amount of output
     *@return Amount object, amount of output
     */
    declare function getValue(): NJSAmount;
    /**
     *Get script (witness script) cryptographic puzzle that determines the conditions to spend the output
     *@return in Bytes (variable size depending on type of script P2PKH, P2SH), locking script to spend UTXO
     */
    declare function getScript(): Object;
    declare function parseScript(): NJSBitcoinLikeScript;
    /**
     *Get address that spent the output
     *@return Optional String, address that spent
     */
    declare function getAddress(): ?string;
    declare function getDerivationPath(): ?NJSDerivationPath;
}
/**Class representing Bitcoin block */
declare class NJSBitcoinLikeBlock
{
    /**
     *Hash of block
     *@return string representing hash of this block
     */
    declare function getHash(): string;
    /**
     *Height of block in blockchain
     *@return 64 bits integer, height of block
     */
    declare function getHeight(): number;
    /**
     *Timestamp when block was mined
     *@return Date object, date when block was appended to blockchain
     */
    declare function getTime(): Date;
}
/**Class representing a Bitcoin transaction */
declare class NJSBitcoinLikeTransaction
{
    /** Get the hash of the transaction. */
    declare function getHash(): string;
    /** Get the input of the transaction */
    declare function getInputs(): Array<NJSBitcoinLikeInput>;
    /** Get the output of the transaction */
    declare function getOutputs(): Array<NJSBitcoinLikeOutput>;
    /** Get the block in which the transaction is inserted if the transaction is confirmed. */
    declare function getBlock(): ?NJSBitcoinLikeBlock;
    /** Get the lock time of the transaction. */
    declare function getLockTime(): number;
    /** Get the amount of fees of the transaction. */
    declare function getFees(): NJSAmount;
    /**
     * Get the time when the transaction was issued or the time of the block including
     * this transaction
     */
    declare function getTime(): Date;
    /** Get the timestamps serialized in the raw transaction if the underlying currency handles it. */
    declare function getTimestamp(): ?number;
    /** Get Transaction version */
    declare function getVersion(): number;
    /** Serialize the transaction to its raw format. */
    declare function serialize(): Object;
    /** Serialize outputs of the raw transaction into a byte array using the bitcoin transaction format. */
    declare function serializeOutputs(): Object;
    /** Get the witness if the underlying transaction is a segwit transaction. */
    declare function getWitness(): ?Object;
    /**
     * Estimate the size of the raw transaction in bytes. This method returns a minimum estimated size and a maximum estimated
     * size.
     */
    declare function getEstimatedSize(): EstimatedSize;
}
/**Class representing a Bitcoin Operation */
declare class NJSBitcoinLikeOperation
{
    /**
     *Get operation's transaction
     *@return BitcoinLikeTransaction object
     */
    declare function getTransaction(): NJSBitcoinLikeTransaction;
}
declare class NJSBitcoinLikeTransactionBuilder
{
    /**
     * Add the given input to the final transaction.
     * @param transactionhash The hash of the transaction in where the UTXO can be located.
     * @params index Index of the UTXO in the previous transaction
     * @params sequence Sequence number to add at the end of the input serialization. This can be used for RBF transaction
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addInput(transactionHash: string, index: number, sequence: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Add the given output to the final transaction
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addOutput(amount: NJSAmount, script: NJSBitcoinLikeScript): NJSBitcoinLikeTransactionBuilder;
    /**
     * If needed the transaction will send its change to the given path. It is possible to add multiple change path.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function addChangePath(path: string): NJSBitcoinLikeTransactionBuilder;
    /**
     * Exclude UTXO from the coin selection (alias UTXO picking). You can call this method multiple times to exclude multiple
     * UTXO.
     * @param transactionHash The hash of the transaction in which this UTXO can be found.
     * @param outputIndex The position of the output in the previous transaction,
     * @return A reference on the same builder in order to chain calls.
     */
    declare function excludeUtxo(transactionHash: string, outputIndex: number): NJSBitcoinLikeTransactionBuilder;
    /** @return A reference on the same builder in order to chain calls. */
    declare function setNumberOfChangeAddresses(count: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the maximum amount per change output. By default there is no max amount.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setMaxAmountOnChange(amount: NJSAmount): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the minimum amount per change output. By default this value is the dust value of the currency.
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setMinAmountOnChange(amount: NJSAmount): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the UTXO picking strategy (see [[BitcoinLikePickingStrategy]]).
     * @param strategy The strategy to adopt in order to select which input to use in the transaction.
     * @param sequence The sequence value serialized at the end of the raw transaction. If you don't know what to put here
     * just use 0xFFFFFF
     * @return A reference on the same builder in order to chain calls.
     */
    declare function pickInputs(strategy: BitcoinLikePickingStrategy, sequence: number): NJSBitcoinLikeTransactionBuilder;
    /**
     * Send funds to the given address. This method can be called multiple times to send to multiple addresses.
     * @param amount The value to send
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function sendToAddress(amount: NJSAmount, address: string): NJSBitcoinLikeTransactionBuilder;
    /**
     * Send all available funds to the given address.
     * @param address Address of the recipient
     * @return A reference on the same builder in order to chain calls.
     */
    declare function wipeToAddress(address: string): NJSBitcoinLikeTransactionBuilder;
    /**
     * Set the amount of fees per byte (of the raw transaction).
     * @return A reference on the same builder in order to chain calls.
     */
    declare function setFeesPerByte(fees: NJSAmount): NJSBitcoinLikeTransactionBuilder;
    /** Build a transaction from the given builder parameters. */
    declare function build(callback: NJSBitcoinLikeTransactionCallback);
    /**
     * Creates a clone of this builder.
     * @return A copy of the current builder instance.
     */
    declare function clone(): NJSBitcoinLikeTransactionBuilder;
    /** Reset the current instance to its initial state */
    declare function reset();
    static declare function parseRawUnsignedTransaction(currency: Currency, rawTransaction: Object): NJSBitcoinLikeTransaction;
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSBitcoinLikeTransactionCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSBitcoinLikeTransaction, error: ?Error);
}
/**Class representing a Bitcoin account */
declare class NJSBitcoinLikeAccount
{
    /**
     *Get UTXOs of account in a given range
     *@param from, integer, lower bound for account's UTXO's index
     *@param to, integer, upper bound for account's UTXO's index
     *@param callback, ListCallback object which returns a list of BitcoinLikeOutput if getUTXO succeed
     */
    declare function getUTXO(from: number, to: number, callback: NJSBitcoinLikeOutputListCallback);
    /**
     *Get UTXOs count of account
     *@param callback, Callback object which returns number of UTXO owned by this account
     */
    declare function getUTXOCount(callback: NJSI32Callback);
    declare function broadcastRawTransaction(transaction: Object, callback: NJSStringCallback);
    declare function broadcastTransaction(transaction: NJSBitcoinLikeTransaction, callback: NJSStringCallback);
    declare function buildTransaction(): NJSBitcoinLikeTransactionBuilder;
}
/**
 *Callback triggered by main completed task,
 *returns optional result as list of template type T
 */
declare class NJSBitcoinLikeOutputListCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSBitcoinLikeOutput>, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSStringCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?string, error: ?Error);
}
declare class NJSBitcoinLikeWallet
{
}
/**Class respresenting a pool of wallets */
declare class NJSWalletPool
{
    /**
     *Create a new instance of WalletPool object
     *@param name, string, name of the wallet pool
     *@param password, optional string, password to lock wallet pool
     *@param http, HttpClient object, http client used for all calls made by wallet pool (and aggregated wallets)
     *@param webSocketClient, WebSocketClient object, socket through which wallet pool observe and get notified (explorer, DBs ...)
     *@param pathResolver, PathResolver Object, resolve paths to logs, databases, preferences ...
     *@param logPrinter, LogPrinter object, used to dump/log for debug purpose
     *@param dispatcher, ThreadDispatcher object, responsable of dispatching task through available threads
     *@param rng, RandomNumberGenerator object, needed for generating random numbers (for seeds, salts ...)
     *@param backend, DatabseBackend object, DB in which wallet pool store all required infos (created wallets, their options, their accounts ...)
     *@param configuration, DynamicObject object, desired configuration for this wallet pool
     *@return WalletPool object, instance of WalletPool
     */
    static declare function newInstance(name: string, password: ?string, httpClient: NJSHttpClient, webSocketClient: NJSWebSocketClient, pathResolver: NJSPathResolver, logPrinter: NJSLogPrinter, dispatcher: NJSThreadDispatcher, rng: NJSRandomNumberGenerator, backend: NJSDatabaseBackend, configuration: NJSDynamicObject): NJSWalletPool;
    /**
     *Return used logger to dump logs in defined log path by PathResolver
     *@return Logger object
     */
    declare function getLogger(): NJSLogger;
    /**
     *Return name given to wallet pool
     *@return string
     */
    declare function getName(): string;
    /**
     *Return preferences of wallet pool (deduced from configuration)
     *@return Preferences object
     */
    declare function getPreferences(): NJSPreferences;
    /**
     *Return number of wallets instanciated under wallet pool
     *@param callback, Callback object returns a 32 bits integer, count of wallets
     */
    declare function getWalletCount(callback: NJSI32Callback);
    /**
     *Get instanciated wallets having index in a given range
     *@param from, 32 bits integer, lower bound of indices to pick
     *@param to, 32 bits integer, upper bound of indices to pick
     *@param callback, ListCallback object returns a list of Wallet objects
     */
    declare function getWallets(from: number, size: number, callback: NJSWalletListCallback);
    /**
     *Get wallet with a giver name
     *@param name, string, name of wallet to look for
     *@param callback, Callback object returns a Wallet object
     */
    declare function getWallet(name: string, callback: NJSWalletCallback);
    /**
     *Instanciate a new wallet under wallet pool
     *@param name, string, name of newly created wallet
     *@param currency, Currency object, currency of the wallet
     *@param configuration, DynamicObject object, configuration of wallet (preferences)
     *@param callback, Callback object returning a Wallet object
     */
    declare function createWallet(name: string, currency: Currency, configuration: NJSDynamicObject, callback: NJSWalletCallback);
    /**
     *Return all supported currencies by wallet pool, at least one wallet support one of returned currencies
     *@param callback, ListCallback object, returns a list of Currency objects
     */
    declare function getCurrencies(callback: NJSCurrencyListCallback);
    /**
     *Return currency of a specific wallet
     *@param name, wallet's name to look for
     *@param callback, Callback object returning a Currency object
     */
    declare function getCurrency(name: string, callback: NJSCurrencyCallback);
    /**
     *Return last block of blockchain of a given currency (if it is supported by the wallet pool)
     *@param name, string, name of currency we are interested into getting it's blockchain's last block
     *@param callback, Callback object returns a Block object
     */
    declare function getLastBlock(currencyName: string, callback: NJSBlockCallback);
    /**
     *Get event bus (handler) through which wallet pool observe and gets notified (explorers, DBs ...)
     *@param EventBus object
     */
    declare function getEventBus(): NJSEventBus;
    /**
     *Erase data (in user's DB) relative to wallet since given date
     *@param date, start date of data deletion
     */
    declare function eraseDataSince(date: Date, callback: NJSErrorCodeCallback);
}
/**
 *Callback triggered by main completed task,
 *returns optional result as list of template type T
 */
declare class NJSWalletListCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<NJSWallet>, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSWalletCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSWallet, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result as list of template type T
 */
declare class NJSCurrencyListCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type list<T>, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Array<Currency>, error: ?Error);
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSCurrencyCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?Currency, error: ?Error);
}
/**Class representing a wallet pool builder (to instanciate a wallet pool) */
declare class NJSWalletPoolBuilder
{
    /**
     *Set http client to be used for wallet pool build
     *@param client, HttpClient
     *@return WalletPoolBuilder object, instance with wallet pool http client set
     */
    declare function setHttpClient(client: NJSHttpClient): NJSWalletPoolBuilder;
    /**
     *Set web socket client, through which wallet pool will listen and get notified (by explorers, DBs...)
     *@param client, WebSocketClient object
     *@reutnr WalletPoolBuilder object, instance with wallet pool web socket client set
     */
    declare function setWebsocketClient(client: NJSWebSocketClient): NJSWalletPoolBuilder;
    /**
     *Set path resolver that will be used for wallet pool creation to resolve wallet pool's (DB's, logs, preferences ...) paths
     *@param pathResolver, Pathresolver object
     *@param WalletPoolBuilder object, instance with wallet pool path resolver set
     */
    declare function setPathResolver(pathResolver: NJSPathResolver): NJSWalletPoolBuilder;
    /**
     *Set log printer that will be used for wallet pool creation to dump wallet pool's logs (for debug purposes)
     *@param printer, LogPrinter object
     *@param WalletPoolBuilder object, instance with wallet pool logger set
     */
    declare function setLogPrinter(printer: NJSLogPrinter): NJSWalletPoolBuilder;
    /**
     *Set thread dispatcher that will be used for wallet pool creation to dispatch wallet pool's tasks through different threads
     *@param dispatcher, ThreadDispatcher object
     *@param WalletPoolBuilder object, instance with wallet pool thread dispatcher set
     */
    declare function setThreadDispatcher(dispatcher: NJSThreadDispatcher): NJSWalletPoolBuilder;
    /**
     *Set name that will be used for wallet pool creation
     *@param name, string
     *@return WalletPoolBuilder object, instance with wallet pool name set
     */
    declare function setName(name: string): NJSWalletPoolBuilder;
    /**
     *Set password that will be used for wallet pool creation
     *@param password, string
     *@return WalletPoolBuilder object, with wallet pool password set
     */
    declare function setPassword(password: string): NJSWalletPoolBuilder;
    /**
     *Set random number generator that will be used for wallet pool creation
     *@param rng, RandomNumberGenerator object
     *@return WalletPoolBuilder object, with wallet pool random number generator set
     */
    declare function setRandomNumberGenerator(rng: NJSRandomNumberGenerator): NJSWalletPoolBuilder;
    /**
     *Set database that will be used for wallet pool creation, it will store all wallet pool's data (created wallets, accounts, preferences ...)
     *@param backend, DatabaseBackend object
     *@return WalletPoolBuilder object, with wallet pool database set
     */
    declare function setDatabaseBackend(backend: NJSDatabaseBackend): NJSWalletPoolBuilder;
    /**
     *Set configuration that will be used for wallet pool creation
     *@param configuration, DynamicObject object
     *@return WalletPoolBuilder object, with wallet pool configuration set
     */
    declare function setConfiguration(configuration: NJSDynamicObject): NJSWalletPoolBuilder;
    /**
     *Create wallet pool
     *@param callback, Callback object returning a WalletPool instance
     */
    declare function build(listener: NJSWalletPoolCallback);
    /**
     *Create an instance of the wallet pool builder
     *@return WalletPoolBuilder object
     */
    static declare function createInstance(): NJSWalletPoolBuilder;
}
/**
 *Callback triggered by main completed task,
 *returns optional result of template type T
 */
declare class NJSWalletPoolCallback
{
    /**
     * Method triggered when main task complete
     * @params result optional of type T, non null if main task failed
     * @params error optional of type Error, non null if main task succeeded
     */
    declare function onCallback(result: ?NJSWalletPool, error: ?Error);
}
declare class NJSWebSocketConnection
{
    declare function onConnect(connectionId: number);
    declare function onClose();
    declare function onMessage(data: string);
    declare function onError(code: ErrorCode, message: string);
    declare function getConnectionId(): number;
}
declare class NJSWebSocketClient
{
    declare function connect(url: string, connection: NJSWebSocketConnection);
    declare function send(connection: NJSWebSocketConnection, data: string);
    declare function disconnect(connection: NJSWebSocketConnection);
}
/**Class representing an Http connection */
declare class NJSHttpUrlConnection
{
    /**
     * Gets the HTTP response status code
     * @return The HTTP response status code
     */
    declare function getStatusCode(): number;
    /**
     * Gets the HTTP response status text
     * @return The HTTP response status text
     */
    declare function getStatusText(): string;
    /**
     * Gets the HTTP response headers
     * @return The HTTP response headers
     */
    declare function getHeaders(): Map<string, string>;
    /**
     * Reads available HTTP response body. This method will be called multiple times until it returns a empty bytes array.
     * @returns A chunk of the body data wrapped into a HttpReadBodyResult (for error management)
     */
    declare function readBody(): HttpReadBodyResult;
}
/**Class representing an Http request */
declare class NJSHttpRequest
{
    /**
     *Get method of request
     *@return HttpMethod enum entry
     */
    declare function getMethod(): HttpMethod;
    /**
     *Get headers set in the request
     *@return Map with key and value of type string
     */
    declare function getHeaders(): Map<string, string>;
    /**
     *Get body of request
     *@return binary
     */
    declare function getBody(): Object;
    /**
     *Get Url of request
     *@return string
     */
    declare function getUrl(): string;
    /**
     *Method called when reauest is completed
     *@param response, Optional HttpUrlConnection object, response of request if succeed
     *@param error, optional Error structure, error returned in case of request failure
     */
    declare function complete(response: ?NJSHttpUrlConnection, error: ?Error);
}
/**Class representing the http client performing the http requests */
declare class NJSHttpClient
{
    /**
     *Execute a giver Http request\
     *@param request, HttpRequest object, requestr to execute
     */
    declare function execute(request: NJSHttpRequest);
}
/** Immutable class representing a potentially very long number */
declare class NJSBigInt
{
    /**
     * Adds two BigInt and returns a new BigInt with the result.
     * @params i Value to be added to this BigInt
     * @return The result of this + i
     */
    declare function add(i: NJSBigInt): NJSBigInt;
    /**
     * Subtracts two BigInt and returns a new BigInt with result.
     * @params i Value to be subtracted to this BigInt
     * @return The result of this - i
     */
    declare function subtract(i: NJSBigInt): NJSBigInt;
    /**
     * Multiplies two BigInt and returns a new BigInt with result.
     * @params i Value to be multiplied by this BigInt
     * @return The result of this * i
     */
    declare function multiply(i: NJSBigInt): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result.
     * @params i Value by which this BigInt will be divided
     * @return The result of this / i
     */
    declare function divide(i: NJSBigInt): NJSBigInt;
    /**
     * Divides two BigInt and returns a new BigInt with result of the division and the remainder.
     * @params i Value by which this BigInteger is to be divided, and the remainder computed
     * @return A tuple of [this / i, this % i]
     */
    declare function divideAndRemainder(i: NJSBigInt): Array<NJSBigInt>;
    /**
     * Raises this BigInt with an interger value.
     * @params i The exponent to which thi BigInt is raised
     * @return The result of this ^ exponent
     */
    declare function pow(exponent: number): NJSBigInt;
    /**
     * Formats this BigInt to a decimal string (e.g. BigInt("12345").toDecimalString(1, ".", ",") => "1,234.5")
     * @params precision The power of ten by wich this BigInt is divided
     * @params decimalSeparator The separator to use between the integer part and the decimal part
     * @params thousandSeparator The separator to use between each group of thousand units
     * @return The BigInt formatted as a decimal string
     */
    declare function toDecimalString(precision: number, decimalSeparator: string, thousandSeparator: string): string;
    /**
     * Formats this BigInt to the interger representation of its internal value.
     * @params radix The radix of the number representation in which to format (right now 10 or 16)
     */
    declare function toString(radix: number): string;
    /**
     * Returns the int representation of this BigInt. Note that if the BigInt is greater than 4 bytes the returned value
     * will be meaningless.
     * @return The int representation of this BigInt
     */
    declare function intValue(): number;
    /**
     * Compares two BigInt together.
     * @param i The value to compare with this BigInt
     * @return a positive value if this > i. A negative value if this < i. 0 if the two BigInts are equal
     */
    declare function compare(i: NJSBigInt): number;
    /**
     * Creates a BigInt with a decimal string (e.g. "1.2000"). Note that every non numeric characters (except the decimal separator)
     * are ignored (e.g. "1ledger000" will be equal to "1000")
     * @param s The string with the decimal representation of the BigInt
     * @param precision The power of ten by which your decimal number must be multiplied in order to get his integer representation
     * @params decimalSeparator The decimal separator used by this string representation
     * @return The created BigInt
     */
    static declare function fromDecimalString(s: string, precision: number, decimalSeparator: string): NJSBigInt;
    /**
     * Creates a BigInt with an integer string expressed in hexadecimal or decimal radix.
     * @param s The string to parse
     * @param radix The radix of the number representation (right now 10 or 16)
     * @return The created BigInt
     */
    static declare function fromIntegerString(s: string, radix: number): NJSBigInt;
    /**
     * Creates a BigInt from a int64 value
     * @param l The value to convert
     * @return The created BigInt
     */
    static declare function fromLong(l: number): NJSBigInt;
}
/**
 * Module used to resolve file paths. libledger-core has its own iternal representation of the file system that may not
 * be adapted for the runtime platform. All path given to the PathResolver are absolute.
 */
declare class NJSPathResolver
{
    /**
     * Resolves the path for a SQLite database file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveDatabasePath(path: string): string;
    /**
     * Resolves the path of a single log file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolveLogFilePath(path: string): string;
    /**
     * Resolves the path for a json file.
     * @param path The path to resolve.
     * @return The resolved path.
     */
    declare function resolvePreferencesPath(path: string): string;
}
/**
 *Class representing a runnable object
 *A runnable, needs a specific execution context (refer to ExecutionContext) to run
 */
declare class NJSRunnable
{
    /**Trigger runnable execution */
    declare function run();
}
/**Class representing a lock, for thread safety purposes */
declare class NJSLock
{
    /**
     *Acquire lock by thread calling this method,
     *If Lock already acquired by another thread, execution of calling thread should be blocked
     *until the other thread call the unlock method
     */
    declare function lock();
    /**
     *Try to acquire lock
     *If Lock already aquired by another thread, method returns false for calling thread
     *without blocking its execution
     *@return bool, return true if Lock acquire by calling thread, false otherwise
     */
    declare function tryLock(): boolean;
    /**Release Lock ownership by calling thread */
    declare function unlock();
}
/**Class representing context in which tasks get executed */
declare class NJSExecutionContext
{
    /**
     *Execute a given runnable
     *@param runnalbe, Runnable object
     */
    declare function execute(runnable: NJSRunnable);
    /**
     *Execute a given runnable with a delay
     *@param runnalbe, Runnable object
     *@param millis, 64 bits integer, delay in milli-seconds
     */
    declare function delay(runnable: NJSRunnable, millis: number);
}
/**Class representing a thread dispatcher */
declare class NJSThreadDispatcher
{
    /**
     *Get an execution context where tasks are executed sequentially
     *@param name, string, name of execution context to retrieve
     *@return ExecutionContext object
     */
    declare function getSerialExecutionContext(name: string): NJSExecutionContext;
    /**
     *Get an execution context where tasks are executed in parallel thanks to a thread pool
     *where a system of inter-thread communication was designed
     *@param name, string, name of execution context to retrieve
     *@return ExecutionContext object
     */
    declare function getThreadPoolExecutionContext(name: string): NJSExecutionContext;
    /**
     *Get main execution context (generally where tasks that should never get blocked are executed)
     *@return ExecutionContext object
     */
    declare function getMainExecutionContext(): NJSExecutionContext;
    /**
     *Get lock to handle multithreading
     *@return Lock object
     */
    declare function newLock(): NJSLock;
}
/**
 *Class representing a printer of errors, warnings, infos ... (at runtime)
 *Printed logs are stored in path set by PathResolver::resolveLogFilePath
 */
declare class NJSLogPrinter
{
    /**
     *Print different encountered errors
     *@param message, string
     */
    declare function printError(message: string);
    /**
     *Print useful information messages
     *@param message, string
     */
    declare function printInfo(message: string);
    /**
     *Print debug messages
     *@param message string
     */
    declare function printDebug(message: string);
    /**
     *Print warning messages
     *@param message, string
     */
    declare function printWarning(message: string);
    /**
     *Print messages from APDU comand interpretation loop
     *@param message, string
     */
    declare function printApdu(message: string);
    /**
     *Print critical errors causing a core dump or error from which recovery is impossible
     *@param message, string
     */
    declare function printCriticalError(message: string);
    /**
     *Get context in which printer is executed (print)
     *@return ExecutionContext object
     */
    declare function getContext(): NJSExecutionContext;
}
/**Class to print logs to console */
declare class NJSLogger
{
    /**
     *Print debug message to console
     *@param tag, string
     *@param message, string
     */
    declare function d(tag: string, message: string);
    /**
     *Print information message to console
     *@param tag, string
     *@param message, string
     */
    declare function i(tag: string, message: string);
    /**
     *Print error message to console
     *@param tag, string
     *@param message, string
     */
    declare function e(tag: string, message: string);
    /**
     *Print warning message to console
     *@param tag, string
     *@param message, string
     */
    declare function w(tag: string, message: string);
    /**
     *Print critical error message to console
     *@param tag, string
     *@param message, string
     */
    declare function c(tag: string, message: string);
}
declare class NJSLedgerCore
{
    /**
     * Gets the version of the library as a human readable string.
     * @return The version of the library (e.g. '1.0.1')
     */
    static declare function getStringVersion(): string;
    /**
     * Get the integer version of the Library
     * @return The integer version of the library
     */
    static declare function getIntVersion(): number;
}
