// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from big_int.djinni

package co.ledger.core;

import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicBoolean;

/** Immutable class representing a potentially very long number */
public abstract class BigInt {
    /**
     * Adds two BigInt and returns a new BigInt with the result.
     * @params i Value to be added to this BigInt
     * @return The result of this + i
     */
    public abstract BigInt add(BigInt i);

    /**
     * Subtracts two BigInt and returns a new BigInt with result.
     * @params i Value to be subtracted to this BigInt
     * @return The result of this - i
     */
    public abstract BigInt subtract(BigInt i);

    /**
     * Multiplies two BigInt and returns a new BigInt with result.
     * @params i Value to be multiplied by this BigInt
     * @return The result of this * i
     */
    public abstract BigInt multiply(BigInt i);

    /**
     * Divides two BigInt and returns a new BigInt with result.
     * @params i Value by which this BigInt will be divided
     * @return The result of this / i
     */
    public abstract BigInt divide(BigInt i);

    /**
     * Divides two BigInt and returns a new BigInt with result of the division and the remainder.
     * @params i Value by which this BigInteger is to be divided, and the remainder computed
     * @return A tuple of [this / i, this % i]
     */
    public abstract ArrayList<BigInt> divideAndRemainder(BigInt i);

    /**
     * Raises this BigInt with an interger value.
     * @params i The exponent to which thi BigInt is raised
     * @return The result of this ^ exponent
     */
    public abstract BigInt pow(int exponent);

    /**
     * Formats this BigInt to a decimal string (e.g. BigInt("12345").toDecimalString(1, ".", ",") => "1,234.5")
     * @params precision The power of ten by wich this BigInt is divided
     * @params decimalSeparator The separator to use between the integer part and the decimal part
     * @params thousandSeparator The separator to use between each group of thousand units
     * @return The BigInt formatted as a decimal string
     */
    public abstract String toDecimalString(int precision, String decimalSeparator, String thousandSeparator);

    /**
     * Formats this BigInt to the interger representation of its internal value.
     * @params radix The radix of the number representation in which to format (right now 10 or 16)
     */
    public abstract String toString(int radix);

    /**
     * Returns the int representation of this BigInt. Note that if the BigInt is greater than 4 bytes the returned value
     * will be meaningless.
     * @return The int representation of this BigInt
     */
    public abstract int intValue();

    /**
     * Compares two BigInt together.
     * @param i The value to compare with this BigInt
     * @return a positive value if this > i. A negative value if this < i. 0 if the two BigInts are equal
     */
    public abstract int compare(BigInt i);

    /**
     * Creates a BigInt with a decimal string (e.g. "1.2000"). Note that every non numeric characters (except the decimal separator)
     * are ignored (e.g. "1ledger000" will be equal to "1000")
     * @param s The string with the decimal representation of the BigInt
     * @param precision The power of ten by which your decimal number must be multiplied in order to get his integer representation
     * @params decimalSeparator The decimal separator used by this string representation
     * @return The created BigInt
     */
    public static native BigInt fromDecimalString(String s, int precision, String decimalSeparator);

    /**
     * Creates a BigInt with an integer string expressed in hexadecimal or decimal radix.
     * @param s The string to parse
     * @param radix The radix of the number representation (right now 10 or 16)
     * @return The created BigInt
     */
    public static native BigInt fromIntegerString(String s, int radix);

    /**
     * Creates a BigInt from a int64 value
     * @param l The value to convert
     * @return The created BigInt
     */
    public static native BigInt fromLong(long l);

    private static final class CppProxy extends BigInt
    {
        private final long nativeRef;
        private final AtomicBoolean destroyed = new AtomicBoolean(false);

        private CppProxy(long nativeRef)
        {
            if (nativeRef == 0) throw new RuntimeException("nativeRef is zero");
            this.nativeRef = nativeRef;
        }

        private native void nativeDestroy(long nativeRef);
        public void destroy()
        {
            boolean destroyed = this.destroyed.getAndSet(true);
            if (!destroyed) nativeDestroy(this.nativeRef);
        }
        protected void finalize() throws java.lang.Throwable
        {
            destroy();
            super.finalize();
        }

        @Override
        public BigInt add(BigInt i)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_add(this.nativeRef, i);
        }
        private native BigInt native_add(long _nativeRef, BigInt i);

        @Override
        public BigInt subtract(BigInt i)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_subtract(this.nativeRef, i);
        }
        private native BigInt native_subtract(long _nativeRef, BigInt i);

        @Override
        public BigInt multiply(BigInt i)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_multiply(this.nativeRef, i);
        }
        private native BigInt native_multiply(long _nativeRef, BigInt i);

        @Override
        public BigInt divide(BigInt i)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_divide(this.nativeRef, i);
        }
        private native BigInt native_divide(long _nativeRef, BigInt i);

        @Override
        public ArrayList<BigInt> divideAndRemainder(BigInt i)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_divideAndRemainder(this.nativeRef, i);
        }
        private native ArrayList<BigInt> native_divideAndRemainder(long _nativeRef, BigInt i);

        @Override
        public BigInt pow(int exponent)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_pow(this.nativeRef, exponent);
        }
        private native BigInt native_pow(long _nativeRef, int exponent);

        @Override
        public String toDecimalString(int precision, String decimalSeparator, String thousandSeparator)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_toDecimalString(this.nativeRef, precision, decimalSeparator, thousandSeparator);
        }
        private native String native_toDecimalString(long _nativeRef, int precision, String decimalSeparator, String thousandSeparator);

        @Override
        public String toString(int radix)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_toString(this.nativeRef, radix);
        }
        private native String native_toString(long _nativeRef, int radix);

        @Override
        public int intValue()
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_intValue(this.nativeRef);
        }
        private native int native_intValue(long _nativeRef);

        @Override
        public int compare(BigInt i)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_compare(this.nativeRef, i);
        }
        private native int native_compare(long _nativeRef, BigInt i);
    }
}
