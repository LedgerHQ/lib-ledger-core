// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from bitcoin_like_wallet.djinni

package com.ledger.reactnative;

import BitcoinLikeTransaction;
import RCTCoreAmount;
import RCTCoreBitcoinLikeBlock;
import RCTCoreBitcoinLikeInput;
import RCTCoreBitcoinLikeOutput;
import RCTCoreEstimatedSize;
import co.ledger.core.Amount;
import co.ledger.core.BitcoinLikeBlock;
import co.ledger.core.BitcoinLikeInput;
import co.ledger.core.BitcoinLikeOutput;
import co.ledger.core.EstimatedSize;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import java.util.ArrayList;
import java.util.Date;
import java.util.UUID;;

/**Class representing a Bitcoin transaction */
public class RCTCoreBitcoinLikeTransaction extends ReactContextBaseJavaModule {

    private final ReactApplicationContext reactContext;
    private Map<String, BitcoinLikeTransaction> javaObjects;

    public RNLedgerCoreModule(ReactApplicationContext reactContext)
    {
        super(reactContext);
        this.reactContext = reactContext;
        this.javaObjects = new HashMap<String, BitcoinLikeTransaction>();
    }

    @Override
    public String getName()
    {
        return "RCTCoreBitcoinLikeTransaction";
    }

    /** Get the hash of the transaction. */
    @ReactMethod
    public void getHash(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getHash method");
            }

            String javaResult = currentInstanceObj.getHash();
            Map<String, String> result = new HashMap<String, String>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getHash : Failed to return String from getHash method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Get the input of the transaction */
    @ReactMethod
    public void getInputs(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getInputs method");
            }

            ArrayList<BitcoinLikeInput> javaResult = currentInstanceObj.getInputs();

            ArrayList<HashMap <String, String>> result = new ArrayList<HashMap <String, String>>();
            for (HashMap <String, String> objcResult_elem : objcResult)
            {
                String uuid = UUID.randomUUID().toString();
                RCTCoreBitcoinLikeInput rctImpl_objcResult_elem = (RCTCoreBitcoinLikeInput)self.bridge moduleForName("RCTCoreBitcoinLikeInput");
                rctImpl_objcResult_elem.javaObjects.put(uuid, objcResult_elem);
                Map<String, String> result_elem = new HashMap<String, String>();
                result_elem.put("type","RCTCoreBitcoinLikeInput");
                result_elem.put("uid",uuid);
                result.add(result_elem);
            }

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getInputs : Failed to return ArrayList<BitcoinLikeInput> from getInputs method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Get the output of the transaction */
    @ReactMethod
    public void getOutputs(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getOutputs method");
            }

            ArrayList<BitcoinLikeOutput> javaResult = currentInstanceObj.getOutputs();

            ArrayList<HashMap <String, String>> result = new ArrayList<HashMap <String, String>>();
            for (HashMap <String, String> objcResult_elem : objcResult)
            {
                String uuid = UUID.randomUUID().toString();
                RCTCoreBitcoinLikeOutput rctImpl_objcResult_elem = (RCTCoreBitcoinLikeOutput)self.bridge moduleForName("RCTCoreBitcoinLikeOutput");
                rctImpl_objcResult_elem.javaObjects.put(uuid, objcResult_elem);
                Map<String, String> result_elem = new HashMap<String, String>();
                result_elem.put("type","RCTCoreBitcoinLikeOutput");
                result_elem.put("uid",uuid);
                result.add(result_elem);
            }

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getOutputs : Failed to return ArrayList<BitcoinLikeOutput> from getOutputs method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Get the block in which the transaction is inserted if the transaction is confirmed. */
    @ReactMethod
    public void getBlock(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getBlock method");
            }

            BitcoinLikeBlock javaResult = currentInstanceObj.getBlock();

            String uuid = UUID.randomUUID().toString();
            RCTCoreBitcoinLikeBlock rctImpl_objcResult = (RCTCoreBitcoinLikeBlock)self.bridge moduleForName("RCTCoreBitcoinLikeBlock");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreBitcoinLikeBlock");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getBlock : Failed to return BitcoinLikeBlock from getBlock method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Get the lock time of the transaction. */
    @ReactMethod
    public void getLockTime(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getLockTime method");
            }

            long javaResult = currentInstanceObj.getLockTime();
            Map<String, long> result = new HashMap<String, long>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getLockTime : Failed to return long from getLockTime method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Get the amount of fees of the transaction. */
    @ReactMethod
    public void getFees(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getFees method");
            }

            Amount javaResult = currentInstanceObj.getFees();

            String uuid = UUID.randomUUID().toString();
            RCTCoreAmount rctImpl_objcResult = (RCTCoreAmount)self.bridge moduleForName("RCTCoreAmount");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreAmount");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getFees : Failed to return Amount from getFees method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Get the time when the transaction was issued or the time of the block including
     * this transaction
     */
    @ReactMethod
    public void getTime(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getTime method");
            }

            Date javaResult = currentInstanceObj.getTime();
            Map<String, Date> result = new HashMap<String, Date>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getTime : Failed to return Date from getTime method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Get the timestamps serialized in the raw transaction if the underlying currency handles it. */
    @ReactMethod
    public void getTimestamp(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getTimestamp method");
            }

            Integer javaResult = currentInstanceObj.getTimestamp();
            Map<String, Integer> result = new HashMap<String, Integer>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getTimestamp : Failed to return Integer from getTimestamp method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Get Transaction version */
    @ReactMethod
    public void getVersion(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getVersion method");
            }

            int javaResult = currentInstanceObj.getVersion();
            Map<String, int> result = new HashMap<String, int>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getVersion : Failed to return int from getVersion method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Serialize the transaction to its raw format. */
    @ReactMethod
    public void serialize(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to serialize method");
            }

            byte[] javaResult = currentInstanceObj.serialize();
            Map<String, byte[]> result = new HashMap<String, byte[]>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::serialize : Failed to return byte[] from serialize method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Serialize outputs of the raw transaction into a byte array using the bitcoin transaction format. */
    @ReactMethod
    public void serializeOutputs(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to serializeOutputs method");
            }

            byte[] javaResult = currentInstanceObj.serializeOutputs();
            Map<String, byte[]> result = new HashMap<String, byte[]>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::serializeOutputs : Failed to return byte[] from serializeOutputs method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /** Get the witness if the underlying transaction is a segwit transaction. */
    @ReactMethod
    public void getWitness(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getWitness method");
            }

            byte[] javaResult = currentInstanceObj.getWitness();
            Map<String, byte[]> result = new HashMap<String, byte[]>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getWitness : Failed to return byte[] from getWitness method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     * Estimate the size of the raw transaction in bytes. This method returns a minimum estimated size and a maximum estimated
     * size.
     */
    @ReactMethod
    public void getEstimatedSize(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            BitcoinLikeTransaction currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreBitcoinLikeTransaction instance passed to getEstimatedSize method");
            }

            EstimatedSize javaResult = currentInstanceObj.getEstimatedSize();

            String uuid = UUID.randomUUID().toString();
            RCTCoreEstimatedSize rctImpl_objcResult = (RCTCoreEstimatedSize)self.bridge moduleForName("RCTCoreEstimatedSize");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreEstimatedSize");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreBitcoinLikeTransaction::getEstimatedSize : Failed to return EstimatedSize from getEstimatedSize method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
}
