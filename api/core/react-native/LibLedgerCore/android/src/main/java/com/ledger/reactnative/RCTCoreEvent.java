// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from emitter.djinni

package com.ledger.reactnative;

import Event;
import RCTCoreDynamicObject;
import RCTCoreEvent;
import co.ledger.core.DynamicObject;
import co.ledger.core.Event;
import co.ledger.core.EventCode;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import java.util.UUID;;

/**Class representing an event */
public class RCTCoreEvent extends ReactContextBaseJavaModule {

    private final ReactApplicationContext reactContext;
    private Map<String, Event> javaObjects;

    public RNLedgerCoreModule(ReactApplicationContext reactContext)
    {
        super(reactContext);
        this.reactContext = reactContext;
        this.javaObjects = new HashMap<String, Event>();
    }

    @Override
    public String getName()
    {
        return "RCTCoreEvent";
    }

    /**
     *Get event code (for more details, please refer to EventCode enum)
     *@return EventCode enum entry
     */
    @ReactMethod
    public void getCode(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Event currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreEvent instance passed to getCode method");
            }

            EventCode javaResult = currentInstanceObj.getCode();
            Map<String, EventCode> result = new HashMap<String, EventCode>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreEvent::getCode : Failed to return EventCode from getCode method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Get payload of event
     *@return DynamicObject object
     */
    @ReactMethod
    public void getPayload(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Event currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreEvent instance passed to getPayload method");
            }

            DynamicObject javaResult = currentInstanceObj.getPayload();

            String uuid = UUID.randomUUID().toString();
            RCTCoreDynamicObject rctImpl_objcResult = (RCTCoreDynamicObject)self.bridge moduleForName("RCTCoreDynamicObject");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreDynamicObject");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreEvent::getPayload : Failed to return DynamicObject from getPayload method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Know if event is sticky one
     *@return bool
     */
    @ReactMethod
    public void isSticky(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Event currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreEvent instance passed to isSticky method");
            }

            boolean javaResult = currentInstanceObj.isSticky();
            Map<String, boolean> result = new HashMap<String, boolean>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreEvent::isSticky : Failed to return boolean from isSticky method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *If event is sticky, return sticky tag
     *@return 32 bits integer
     */
    @ReactMethod
    public void getStickyTag(Map<String, String> currentInstance, Promise promise) {
        try
        {
            String sUid = currentInstance.get("uid");
            String sType = currentInstance.get("type");

            Event currentInstanceObj = self.javaObjects.get("uid");
            if (!javaObj)
            {
                throw new Exception("Wrong RCTCoreEvent instance passed to getStickyTag method");
            }

            int javaResult = currentInstanceObj.getStickyTag();
            Map<String, int> result = new HashMap<String, int>();
            result.put("value", javaResult);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreEvent::getStickyTag : Failed to return int from getStickyTag method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
    /**
     *Create a new instance of Event class
     *@param code, EventCode enum entry
     *@param payload, DynamicObject object
     *@return Event instance
     */
    @ReactMethod
    public void newInstance(Map<String, String> currentInstance, EventCode code, HashMap <String, String> payload, Promise promise) {
        try
        {
            Event javaResult = Event.newInstance(code, javaParam_1);

            String uuid = UUID.randomUUID().toString();
            RCTCoreEvent rctImpl_objcResult = (RCTCoreEvent)self.bridge moduleForName("RCTCoreEvent");
            rctImpl_objcResult.javaObjects.put(uuid, objcResult);
            Map<String, String> result = new HashMap<String, String>();
            result.put("type","RCTCoreEvent");
            result.put("uid",uuid);

            if(result)
            {
                promise.resolve(result);
            }
            else
            {
                throw new Exception("RCTCoreEvent::newInstance : Failed to return Event from newInstance method");
            }
        }
        catch(Exception e)
        {
            promise.reject(ERROR, e);
        }
    }
}
