// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from wallet_pool.djinni

#import "RCTCoreLGWalletPool.h"


@implementation RCTCoreLGWalletPool
//Export module
RCT_EXPORT_MODULE(RCTCoreLGWalletPool)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGWalletPool alloc] init];
    }
    return self;
}

/**
 *Create a new instance of WalletPool object
 *@param name, string, name of the wallet pool
 *@param password, optional string, password to lock wallet pool
 *@param http, HttpClient object, http client used for all calls made by wallet pool (and aggregated wallets)
 *@param webSocketClient, WebSocketClient object, socket through which wallet pool observe and get notified (explorer, DBs ...)
 *@param pathResolver, PathResolver Object, resolve paths to logs, databases, preferences ...
 *@param logPrinter, LogPrinter object, used to dump/log for debug purpose
 *@param dispatcher, ThreadDispatcher object, responsable of dispatching task through available threads
 *@param rng, RandomNumberGenerator object, needed for generating random numbers (for seeds, salts ...)
 *@param backend, DatabseBackend object, DB in which wallet pool store all required infos (created wallets, their options, their accounts ...)
 *@param configuration, DynamicObject object, desired configuration for this wallet pool
 *@return WalletPool object, instance of WalletPool
 */
RCT_REMAP_METHOD(newInstance,newInstance:(nonnull NSString *)name
                                password:(nullable NSString *)password
                              httpClient:(nullable id<LGHttpClient>)httpClient
                         webSocketClient:(nullable id<LGWebSocketClient>)webSocketClient
                            pathResolver:(nullable id<LGPathResolver>)pathResolver
                              logPrinter:(nullable id<LGLogPrinter>)logPrinter
                              dispatcher:(nullable id<LGThreadDispatcher>)dispatcher
                                     rng:(nullable id<LGRandomNumberGenerator>)rng
                                 backend:(nullable LGDatabaseBackend *)backend
                           configuration:(nullable LGDynamicObject *)configuration withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[LGWalletPool newInstance:name password:password httpClient:httpClient webSocketClient:webSocketClient pathResolver:pathResolver logPrinter:logPrinter dispatcher:dispatcher rng:rng backend:backend configuration:configuration]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWalletPool::newInstance", nil);
    }
}

/**
 *Return used logger to dump logs in defined log path by PathResolver
 *@return Logger object
 */
RCT_REMAP_METHOD(getLogger,getLoggerWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getLogger]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWalletPool::getLogger", nil);
    }
}

/**
 *Return name given to wallet pool
 *@return string
 */
RCT_REMAP_METHOD(getName,getNameWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getName]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWalletPool::getName", nil);
    }
}

/**
 *Return preferences of wallet pool (deduced from configuration)
 *@return Preferences object
 */
RCT_REMAP_METHOD(getPreferences,getPreferencesWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getPreferences]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWalletPool::getPreferences", nil);
    }
}

/**
 *Return number of wallets instanciated under wallet pool
 *@param callback, Callback object returns a 32 bits integer, count of wallets
 */
RCT_REMAP_METHOD(getWalletCount,getWalletCount:(nullable id<LGI32Callback>)callback) {

    [self.objcImpl getWalletCount:callback];
}

/**
 *Get instanciated wallets having index in a given range
 *@param from, 32 bits integer, lower bound of indices to pick
 *@param to, 32 bits integer, upper bound of indices to pick
 *@param callback, ListCallback object returns a list of Wallet objects
 */
RCT_REMAP_METHOD(getWallets,getWallets:(int32_t)from
                                  size:(int32_t)size
                              callback:(nullable id<LGWalletListCallback>)callback) {

    [self.objcImpl getWallets:from size:size callback:callback];
}

/**
 *Get wallet with a giver name
 *@param name, string, name of wallet to look for
 *@param callback, Callback object returns a Wallet object
 */
RCT_REMAP_METHOD(getWallet,getWallet:(nonnull NSString *)name
                            callback:(nullable id<LGWalletCallback>)callback) {

    [self.objcImpl getWallet:name callback:callback];
}

/**
 *Instanciate a new wallet under wallet pool
 *@param name, string, name of newly created wallet
 *@param currency, Currency object, currency of the wallet
 *@param configuration, DynamicObject object, configuration of wallet (preferences)
 *@param callback, Callback object returning a Wallet object
 */
RCT_REMAP_METHOD(createWallet,createWallet:(nonnull NSString *)name
                                  currency:(nonnull LGCurrency *)currency
                             configuration:(nullable LGDynamicObject *)configuration
                                  callback:(nullable id<LGWalletCallback>)callback) {

    [self.objcImpl createWallet:name currency:currency configuration:configuration callback:callback];
}

/**
 *Return all supported currencies by wallet pool, at least one wallet support one of returned currencies
 *@param callback, ListCallback object, returns a list of Currency objects
 */
RCT_REMAP_METHOD(getCurrencies,getCurrencies:(nullable id<LGCurrencyListCallback>)callback) {

    [self.objcImpl getCurrencies:callback];
}

/**
 *Return currency of a specific wallet
 *@param name, wallet's name to look for
 *@param callback, Callback object returning a Currency object
 */
RCT_REMAP_METHOD(getCurrency,getCurrency:(nonnull NSString *)name
                                callback:(nullable id<LGCurrencyCallback>)callback) {

    [self.objcImpl getCurrency:name callback:callback];
}

/**
 *Return last block of blockchain of a given currency (if it is supported by the wallet pool)
 *@param name, string, name of currency we are interested into getting it's blockchain's last block
 *@param callback, Callback object returns a Block object
 */
RCT_REMAP_METHOD(getLastBlock,getLastBlock:(nonnull NSString *)currencyName
                                  callback:(nullable id<LGBlockCallback>)callback) {

    [self.objcImpl getLastBlock:currencyName callback:callback];
}

/**
 *Get event bus (handler) through which wallet pool observe and gets notified (explorers, DBs ...)
 *@param EventBus object
 */
RCT_REMAP_METHOD(getEventBus,getEventBusWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getEventBus]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWalletPool::getEventBus", nil);
    }
}

/**
 *Erase data (in user's DB) relative to wallet since given date
 *@param date, start date of data deletion
 */
RCT_REMAP_METHOD(eraseDataSince,eraseDataSince:(nonnull NSDate *)date) {

    [self.objcImpl eraseDataSince:date];
}
@end
