// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from wallet.djinni

#import "RCTCoreLGOperationQuery.h"


@implementation RCTCoreLGOperationQuery
//Export module
RCT_EXPORT_MODULE(RCTCoreLGOperationQuery)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGOperationQuery alloc] init];
    }
    return self;
}

/**
 *Apply given order to query's operation
 *@param key, OperationOrderKey object which defines order
 *@param descending, bool
 *@return OperationQuery object, new ordered operation
 */
RCT_REMAP_METHOD(addOrder,addOrder:(LGOperationOrderKey)key
                        descending:(BOOL)descending withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl addOrder:key descending:descending];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperationQuery::addOrder", nil);
    }
}

/**
 *Get applied filter on operation query
 *@return QueryFilter object
 */
RCT_REMAP_METHOD(filter,filterWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl filter];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperationQuery::filter", nil);
    }
}

/**
 *Add offset to the operation query
 *@param from, 64 bits integer
 */
RCT_REMAP_METHOD(offset,offset:(int64_t)from withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl offset:from];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperationQuery::offset", nil);
    }
}

/**
 *Add limit to the operation query results
 *@param count, 64 bits integer
 */
RCT_REMAP_METHOD(limit,limit:(int64_t)count withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl limit:count];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperationQuery::limit", nil);
    }
}

/**
 *TODO
 *Complete the operation query
 */
RCT_REMAP_METHOD(complete,completeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl complete];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperationQuery::complete", nil);
    }
}

/**TODO */
RCT_REMAP_METHOD(partial,partialWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl partial];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGOperationQuery::partial", nil);
    }
}

/**
 *Execute query to retrieve operations
 *@param callback, if execute method succeed, ListCallback object returning a List of Operation objects
 */
RCT_REMAP_METHOD(execute,execute:(nullable id<LGOperationListCallback>)callback) {

    [self.objcImpl execute:callback];
}
@end
