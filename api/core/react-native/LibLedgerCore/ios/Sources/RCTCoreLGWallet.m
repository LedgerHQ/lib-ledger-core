// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from wallet.djinni

#import "RCTCoreLGWallet.h"


@implementation RCTCoreLGWallet
//Export module
RCT_EXPORT_MODULE(RCTCoreLGWallet)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGWallet alloc] init];
    }
    return self;
}

/**
 *Get name of wallet
 *@return string
 */
RCT_REMAP_METHOD(getName,getNameWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getName]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::getName", nil);
    }
}

/**
 *Get account with specific index
 *@param index, 32 bits integer, index of account in wallet
 *@param callback, Callback returning, if getAccount succeed, an Account object with given index
 */
RCT_REMAP_METHOD(getAccount,getAccount:(int32_t)index
                              callback:(nullable id<LGAccountCallback>)callback) {

    [self.objcImpl getAccount:index callback:callback];
}

/**
 *Get number of accounts instanciated under wallet
 *@param callback, Callback returning, if getAccountCount succeed, a 32 bits integer representing number of accounts
 */
RCT_REMAP_METHOD(getAccountCount,getAccountCount:(nullable id<LGI32Callback>)callback) {

    [self.objcImpl getAccountCount:callback];
}

/**
 *Get list of accounts instanciated under wallet in a given range
 *@param offset, 32 bits integer from which we retrieve accounts
 *@param count, 32 bits integer, number of accounts to retrieve
 *@param callback, ListCallback returning, if getAccounts succeed, list of Accounts object
 */
RCT_REMAP_METHOD(getAccounts,getAccounts:(int32_t)offset
                                   count:(int32_t)count
                                callback:(nullable id<LGAccountListCallback>)callback) {

    [self.objcImpl getAccounts:offset count:count callback:callback];
}

/**
 *Get index of next account to create
 *@return callback, Callback returning a 32 bits integer
 */
RCT_REMAP_METHOD(getNextAccountIndex,getNextAccountIndex:(nullable id<LGI32Callback>)callback) {

    [self.objcImpl getNextAccountIndex:callback];
}

/**
 *Return event bus through which wallet synchronizes it's accounts and interact with blockchain
 *@return EventBus object
 */
RCT_REMAP_METHOD(getEventBus,getEventBusWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getEventBus]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::getEventBus", nil);
    }
}

/**
 *Return synchronization status wallet, true if at least one of accounts is synchronizing
 *@return bool
 */
RCT_REMAP_METHOD(isSynchronizing,isSynchronizingWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl isSynchronizing])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::isSynchronizing", nil);
    }
}

/**
 *Start synchronization of all accounts under wallet
 *@return EventBus object through which wallet get notified of account's synchronization status
 */
RCT_REMAP_METHOD(synchronize,synchronizeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl synchronize]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::synchronize", nil);
    }
}

/**
 *Get wallet preferences
 *@return Preferences object
 */
RCT_REMAP_METHOD(getPreferences,getPreferencesWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getPreferences]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::getPreferences", nil);
    }
}

/**
 *Return account's logger which provides all needed (e.g. database) logs
 *@return Logger Object
 */
RCT_REMAP_METHOD(getLogger,getLoggerWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getLogger]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::getLogger", nil);
    }
}

/**
 *Get preferences of specific account
 *@param index, 32 bits integer, account's index
 *@return Preferences object
 */
RCT_REMAP_METHOD(getAccountPreferences,getAccountPreferences:(int32_t)index withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getAccountPreferences:index]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::getAccountPreferences", nil);
    }
}

/**
 * asBitcoinLikeWallet(): Callback<BitcoinLikeWallet>;
 * asEthereumLikeWallet(): Callback<EthereumLikeWallet>;
 * asRippleLikeWallet(): Callback<RippleLikeWallet>;
 *Convert wallet to a Bitcoin one
 *@return BitcoinWallet object
 */
RCT_REMAP_METHOD(asBitcoinLikeWallet,asBitcoinLikeWalletWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl asBitcoinLikeWallet]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::asBitcoinLikeWallet", nil);
    }
}

/**
 *Get currency of wallet
 *@return Currency object
 */
RCT_REMAP_METHOD(getCurrency,getCurrencyWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getCurrency]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::getCurrency", nil);
    }
}

/**
 *Know if wallet is a Bitcoin one
 *@return bool
 */
RCT_REMAP_METHOD(isInstanceOfBitcoinLikeWallet,isInstanceOfBitcoinLikeWalletWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl isInstanceOfBitcoinLikeWallet])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::isInstanceOfBitcoinLikeWallet", nil);
    }
}

/**
 *Know if wallet is a Ethereum one
 *@return bool
 */
RCT_REMAP_METHOD(isInstanceOfEthereumLikeWallet,isInstanceOfEthereumLikeWalletWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl isInstanceOfEthereumLikeWallet])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::isInstanceOfEthereumLikeWallet", nil);
    }
}

/**
 *Know if wallet is a Ripple one
 *@return bool
 */
RCT_REMAP_METHOD(isInstanceOfRippleLikeWallet,isInstanceOfRippleLikeWalletWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl isInstanceOfRippleLikeWallet])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::isInstanceOfRippleLikeWallet", nil);
    }
}

/**
 *Get wallet type
 *@return WalletType object
 */
RCT_REMAP_METHOD(getWalletType,getWalletTypeWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl getWalletType])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGWallet::getWalletType", nil);
    }
}

/**
 *Get last block of blockchain the wallet operates on
 *@param callback, Callback returning a Block object
 */
RCT_REMAP_METHOD(getLastBlock,getLastBlock:(nullable id<LGBlockCallback>)callback) {

    [self.objcImpl getLastBlock:callback];
}

/**
 *Return infos about the creation of specific account
 *@param accountIndex, 32 bits account, index of account in wallet
 *@param callback, Callback returning an AccountCreationInfo
 */
RCT_REMAP_METHOD(getAccountCreationInfo,getAccountCreationInfo:(int32_t)accountIndex
                                                      callback:(nullable id<LGAccountCreationInfoCallback>)callback) {

    [self.objcImpl getAccountCreationInfo:accountIndex callback:callback];
}

/**TODO */
RCT_REMAP_METHOD(getExtendedKeyAccountCreationInfo,getExtendedKeyAccountCreationInfo:(int32_t)accountIndex
                                                                            callback:(nullable id<LGExtendedKeyAccountCreationInfoCallback>)callback) {

    [self.objcImpl getExtendedKeyAccountCreationInfo:accountIndex callback:callback];
}

/**
 *Return infos about the next created account
 *@param callback, Callback returning an AccountCreationInfo
 */
RCT_REMAP_METHOD(getNextAccountCreationInfo,getNextAccountCreationInfo:(nullable id<LGAccountCreationInfoCallback>)callback) {

    [self.objcImpl getNextAccountCreationInfo:callback];
}

/**TODO */
RCT_REMAP_METHOD(getNextExtendedKeyAccountCreationInfo,getNextExtendedKeyAccountCreationInfo:(nullable id<LGExtendedKeyAccountCreationInfoCallback>)callback) {

    [self.objcImpl getNextExtendedKeyAccountCreationInfo:callback];
}

/**
 *Get account from given account creation infos
 *@param accountCreationInfo, AccountCreationInfo object
 *@param callback, Callback returning an Account object with given creation infos
 */
RCT_REMAP_METHOD(newAccountWithInfo,newAccountWithInfo:(nonnull LGAccountCreationInfo *)accountCreationInfo
                                              callback:(nullable id<LGAccountCallback>)callback) {

    [self.objcImpl newAccountWithInfo:accountCreationInfo callback:callback];
}

/**TODO */
RCT_REMAP_METHOD(newAccountWithExtendedKeyInfo,newAccountWithExtendedKeyInfo:(nonnull LGExtendedKeyAccountCreationInfo *)extendedKeyAccountCreationInfo
                                                                    callback:(nullable id<LGAccountCallback>)callback) {

    [self.objcImpl newAccountWithExtendedKeyInfo:extendedKeyAccountCreationInfo callback:callback];
}

/**
 *Erase data (in user's DB) relative to wallet since given date
 *@param date, start date of data deletion
 */
RCT_REMAP_METHOD(eraseDataSince,eraseDataSince:(nonnull NSDate *)date
                                      callback:(nullable id<LGErrorCodeCallback>)callback) {

    [self.objcImpl eraseDataSince:date callback:callback];
}
@end
