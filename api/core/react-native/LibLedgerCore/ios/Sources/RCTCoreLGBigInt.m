// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from big_int.djinni

#import "RCTCoreLGBigInt.h"


@implementation RCTCoreLGBigInt
//Export module
RCT_EXPORT_MODULE(RCTCoreLGBigInt)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGBigInt alloc] init];
    }
    return self;
}

/**
 * Adds two BigInt and returns a new BigInt with the result.
 * @params i Value to be added to this BigInt
 * @return The result of this + i
 */
RCT_REMAP_METHOD(add,add:(nullable LGBigInt *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl add:i];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::add", nil);
    }
}

/**
 * Subtracts two BigInt and returns a new BigInt with result.
 * @params i Value to be subtracted to this BigInt
 * @return The result of this - i
 */
RCT_REMAP_METHOD(subtract,subtract:(nullable LGBigInt *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl subtract:i];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::subtract", nil);
    }
}

/**
 * Multiplies two BigInt and returns a new BigInt with result.
 * @params i Value to be multiplied by this BigInt
 * @return The result of this * i
 */
RCT_REMAP_METHOD(multiply,multiply:(nullable LGBigInt *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl multiply:i];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::multiply", nil);
    }
}

/**
 * Divides two BigInt and returns a new BigInt with result.
 * @params i Value by which this BigInt will be divided
 * @return The result of this / i
 */
RCT_REMAP_METHOD(divide,divide:(nullable LGBigInt *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl divide:i];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::divide", nil);
    }
}

/**
 * Divides two BigInt and returns a new BigInt with result of the division and the remainder.
 * @params i Value by which this BigInteger is to be divided, and the remainder computed
 * @return A tuple of [this / i, this % i]
 */
RCT_REMAP_METHOD(divideAndRemainder,divideAndRemainder:(nullable LGBigInt *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl divideAndRemainder:i];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::divideAndRemainder", nil);
    }
}

/**
 * Raises this BigInt with an interger value.
 * @params i The exponent to which thi BigInt is raised
 * @return The result of this ^ exponent
 */
RCT_REMAP_METHOD(pow,pow:(int32_t)exponent withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl pow:exponent];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::pow", nil);
    }
}

/**
 * Formats this BigInt to a decimal string (e.g. BigInt("12345").toDecimalString(1, ".", ",") => "1,234.5")
 * @params precision The power of ten by wich this BigInt is divided
 * @params decimalSeparator The separator to use between the integer part and the decimal part
 * @params thousandSeparator The separator to use between each group of thousand units
 * @return The BigInt formatted as a decimal string
 */
RCT_REMAP_METHOD(toDecimalString,toDecimalString:(int32_t)precision
                                decimalSeparator:(nonnull NSString *)decimalSeparator
                               thousandSeparator:(nonnull NSString *)thousandSeparator withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl toDecimalString:precision decimalSeparator:decimalSeparator thousandSeparator:thousandSeparator];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::toDecimalString", nil);
    }
}

/**
 * Formats this BigInt to the interger representation of its internal value.
 * @params radix The radix of the number representation in which to format (right now 10 or 16)
 */
RCT_REMAP_METHOD(toString,toString:(int32_t)radix withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl toString:radix];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::toString", nil);
    }
}

/**
 * Returns the int representation of this BigInt. Note that if the BigInt is greater than 4 bytes the returned value
 * will be meaningless.
 * @return The int representation of this BigInt
 */
RCT_REMAP_METHOD(intValue,intValueWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl intValue];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::intValue", nil);
    }
}

/**
 * Compares two BigInt together.
 * @param i The value to compare with this BigInt
 * @return a positive value if this > i. A negative value if this < i. 0 if the two BigInts are equal
 */
RCT_REMAP_METHOD(compare,compare:(nullable LGBigInt *)i withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [self.objcImpl compare:i];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::compare", nil);
    }
}

/**
 * Creates a BigInt with a decimal string (e.g. "1.2000"). Note that every non numeric characters (except the decimal separator)
 * are ignored (e.g. "1ledger000" will be equal to "1000")
 * @param s The string with the decimal representation of the BigInt
 * @param precision The power of ten by which your decimal number must be multiplied in order to get his integer representation
 * @params decimalSeparator The decimal separator used by this string representation
 * @return The created BigInt
 */
RCT_REMAP_METHOD(fromDecimalString,fromDecimalString:(nonnull NSString *)s
                                           precision:(int32_t)precision
                                    decimalSeparator:(nonnull NSString *)decimalSeparator withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [LGBigInt fromDecimalString:s precision:precision decimalSeparator:decimalSeparator];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::fromDecimalString", nil);
    }
}

/**
 * Creates a BigInt with an integer string expressed in hexadecimal or decimal radix.
 * @param s The string to parse
 * @param radix The radix of the number representation (right now 10 or 16)
 * @return The created BigInt
 */
RCT_REMAP_METHOD(fromIntegerString,fromIntegerString:(nonnull NSString *)s
                                               radix:(int32_t)radix withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [LGBigInt fromIntegerString:s radix:radix];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::fromIntegerString", nil);
    }
}

/**
 * Creates a BigInt from a int64 value
 * @param l The value to convert
 * @return The created BigInt
 */
RCT_REMAP_METHOD(fromLong,fromLong:(int64_t)l withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = [LGBigInt fromLong:l];
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBigInt::fromLong", nil);
    }
}
@end
