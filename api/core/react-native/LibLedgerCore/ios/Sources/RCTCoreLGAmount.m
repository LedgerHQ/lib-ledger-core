// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from amount.djinni

#import "RCTCoreLGAmount.h"


@implementation RCTCoreLGAmount
//Export module
RCT_EXPORT_MODULE(RCTCoreLGAmount)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGAmount alloc] init];
    }
    return self;
}

/**
 *Get amount as a BitInt
 *@return BitInt
 */
RCT_REMAP_METHOD(toBigInt,toBigIntWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl toBigInt]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::toBigInt", nil);
    }
}

/**
 *Get currency in which amount was computed
 *@return Currency object
 */
RCT_REMAP_METHOD(getCurrency,getCurrencyWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getCurrency]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::getCurrency", nil);
    }
}

/**
 *Get currency unit in which amount was computed
 *@return CurrencyUnit object
 */
RCT_REMAP_METHOD(getUnit,getUnitWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl getUnit]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::getUnit", nil);
    }
}

/**
 *Convert amount in another currency unit
 *@param CurrencyUnit object, target currency unit
 *@return Amount object, amount in target currency unit
 */
RCT_REMAP_METHOD(toUnit,toUnit:(nonnull LGCurrencyUnit *)unit withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl toUnit:unit]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::toUnit", nil);
    }
}

/**TODO */
RCT_REMAP_METHOD(toMagnitude,toMagnitude:(int32_t)magnitude withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl toMagnitude:magnitude]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::toMagnitude", nil);
    }
}

/**
 *Get amount as string
 *@return string
 */
RCT_REMAP_METHOD(toString,toStringWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl toString]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::toString", nil);
    }
}

/**
 *Get amount as long
 *@reutrn 64 bits integer
 */
RCT_REMAP_METHOD(toLong,toLongWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl toLong])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::toLong", nil);
    }
}

/**
 *Get amount as double
 *@return double
 */
RCT_REMAP_METHOD(toDouble,toDoubleWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :@([self.objcImpl toDouble])};if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::toDouble", nil);
    }
}

/**TODO */
RCT_REMAP_METHOD(format,format:(nonnull LGLocale *)locale
                         rules:(nullable LGFormatRules *)rules withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl format:locale rules:rules]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::format", nil);
    }
}

RCT_REMAP_METHOD(fromHex,fromHex:(nonnull LGCurrency *)currency
                             hex:(nonnull NSString *)hex withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[LGAmount fromHex:currency hex:hex]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::fromHex", nil);
    }
}

RCT_REMAP_METHOD(fromLong,fromLong:(nonnull LGCurrency *)currency
                             value:(int64_t)value withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[LGAmount fromLong:currency value:value]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGAmount::fromLong", nil);
    }
}
@end
