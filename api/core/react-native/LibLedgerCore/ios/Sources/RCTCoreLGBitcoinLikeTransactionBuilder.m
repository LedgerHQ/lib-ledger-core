// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from bitcoin_like_wallet.djinni

#import "RCTCoreLGBitcoinLikeTransactionBuilder.h"


@implementation RCTCoreLGBitcoinLikeTransactionBuilder
//Export module
RCT_EXPORT_MODULE(RCTCoreLGBitcoinLikeTransactionBuilder)

-(instancetype)init
{
    self = [super init];
    //Init Objc implementation
    if(self)
    {
        self.objcImpl = [[LGBitcoinLikeTransactionBuilder alloc] init];
    }
    return self;
}

/**
 * Add the given input to the final transaction.
 * @param transactionhash The hash of the transaction in where the UTXO can be located.
 * @params index Index of the UTXO in the previous transaction
 * @params sequence Sequence number to add at the end of the input serialization. This can be used for RBF transaction
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(addInput,addInput:(nonnull NSString *)transactionHash
                             index:(int32_t)index
                          sequence:(int32_t)sequence withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl addInput:transactionHash index:index sequence:sequence]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::addInput", nil);
    }
}

/**
 * Add the given output to the final transaction
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(addOutput,addOutput:(nullable LGAmount *)amount
                              script:(nullable LGBitcoinLikeScript *)script withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl addOutput:amount script:script]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::addOutput", nil);
    }
}

/**
 * If needed the transaction will send its change to the given path. It is possible to add multiple change path.
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(addChangePath,addChangePath:(nonnull NSString *)path withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl addChangePath:path]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::addChangePath", nil);
    }
}

/**
 * Exclude UTXO from the coin selection (alias UTXO picking). You can call this method multiple times to exclude multiple
 * UTXO.
 * @param transactionHash The hash of the transaction in which this UTXO can be found.
 * @param outputIndex The position of the output in the previous transaction,
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(excludeUtxo,excludeUtxo:(nonnull NSString *)transactionHash
                             outputIndex:(int32_t)outputIndex withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl excludeUtxo:transactionHash outputIndex:outputIndex]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::excludeUtxo", nil);
    }
}

/** @return A reference on the same builder in order to chain calls. */
RCT_REMAP_METHOD(setNumberOfChangeAddresses,setNumberOfChangeAddresses:(int32_t)count withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setNumberOfChangeAddresses:count]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::setNumberOfChangeAddresses", nil);
    }
}

/**
 * Set the maximum amount per change output. By default there is no max amount.
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(setMaxAmountOnChange,setMaxAmountOnChange:(nullable LGAmount *)amount withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setMaxAmountOnChange:amount]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::setMaxAmountOnChange", nil);
    }
}

/**
 * Set the minimum amount per change output. By default this value is the dust value of the currency.
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(setMinAmountOnChange,setMinAmountOnChange:(nullable LGAmount *)amount withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setMinAmountOnChange:amount]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::setMinAmountOnChange", nil);
    }
}

/**
 * Set the UTXO picking strategy (see [[BitcoinLikePickingStrategy]]).
 * @param strategy The strategy to adopt in order to select which input to use in the transaction.
 * @param sequence The sequence value serialized at the end of the raw transaction. If you don't know what to put here
 * just use 0xFFFFFF
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(pickInputs,pickInputs:(LGBitcoinLikePickingStrategy)strategy
                              sequence:(int32_t)sequence withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl pickInputs:strategy sequence:sequence]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::pickInputs", nil);
    }
}

/**
 * Send funds to the given address. This method can be called multiple times to send to multiple addresses.
 * @param amount The value to send
 * @param address Address of the recipient
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(sendToAddress,sendToAddress:(nullable LGAmount *)amount
                                     address:(nonnull NSString *)address withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl sendToAddress:amount address:address]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::sendToAddress", nil);
    }
}

/**
 * Send all available funds to the given address.
 * @param address Address of the recipient
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(wipeToAddress,wipeToAddress:(nonnull NSString *)address withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl wipeToAddress:address]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::wipeToAddress", nil);
    }
}

/**
 * Set the amount of fees per byte (of the raw transaction).
 * @return A reference on the same builder in order to chain calls.
 */
RCT_REMAP_METHOD(setFeesPerByte,setFeesPerByte:(nullable LGAmount *)fees withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl setFeesPerByte:fees]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::setFeesPerByte", nil);
    }
}

/** Build a transaction from the given builder parameters. */
RCT_REMAP_METHOD(build,build:(nullable id<LGBitcoinLikeTransactionCallback>)callback) {

    [self.objcImpl build:callback];
}

/**
 * Creates a clone of this builder.
 * @return A copy of the current builder instance.
 */
RCT_REMAP_METHOD(clone,cloneWithResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[self.objcImpl clone]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::clone", nil);
    }
}

/** Reset the current instance to its initial state */
RCT_EXPORT_METHOD(reset) {

    [self.objcImpl reset];
}

RCT_REMAP_METHOD(parseRawUnsignedTransaction,parseRawUnsignedTransaction:(nonnull LGCurrency *)currency
                                                          rawTransaction:(nonnull NSData *)rawTransaction withResolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {

    id result = @{@"result" :[LGBitcoinLikeTransactionBuilder parseRawUnsignedTransaction:currency rawTransaction:rawTransaction]};
    if(result)
    {
        resolve(result);
    }
    else
    {
        reject(@"impl_call_error", @"Error while calling LGBitcoinLikeTransactionBuilder::parseRawUnsignedTransaction", nil);
    }
}
@end
