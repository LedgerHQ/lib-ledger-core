// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bitcoin/commands.proto

#ifndef PROTOBUF_INCLUDED_bitcoin_2fcommands_2eproto
#define PROTOBUF_INCLUDED_bitcoin_2fcommands_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bitcoin/account.pb.h"
#include "bitcoin/account_config.pb.h"
#include "bitcoin/wallet.pb.h"
#include "bitcoin/operation.pb.h"
#include "common/amount.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bitcoin_2fcommands_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_bitcoin_2fcommands_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_bitcoin_2fcommands_2eproto();
namespace ledger {
namespace core {
namespace message {
namespace bitcoin {
class CreateAccountRequest;
class CreateAccountRequestDefaultTypeInternal;
extern CreateAccountRequestDefaultTypeInternal _CreateAccountRequest_default_instance_;
class CreateAccountResponse;
class CreateAccountResponseDefaultTypeInternal;
extern CreateAccountResponseDefaultTypeInternal _CreateAccountResponse_default_instance_;
class CreateWalletRequest;
class CreateWalletRequestDefaultTypeInternal;
extern CreateWalletRequestDefaultTypeInternal _CreateWalletRequest_default_instance_;
class CreateWalletResponse;
class CreateWalletResponseDefaultTypeInternal;
extern CreateWalletResponseDefaultTypeInternal _CreateWalletResponse_default_instance_;
class GetAccountsRequest;
class GetAccountsRequestDefaultTypeInternal;
extern GetAccountsRequestDefaultTypeInternal _GetAccountsRequest_default_instance_;
class GetAccountsResponse;
class GetAccountsResponseDefaultTypeInternal;
extern GetAccountsResponseDefaultTypeInternal _GetAccountsResponse_default_instance_;
class GetBalanceRequest;
class GetBalanceRequestDefaultTypeInternal;
extern GetBalanceRequestDefaultTypeInternal _GetBalanceRequest_default_instance_;
class GetBalanceResponse;
class GetBalanceResponseDefaultTypeInternal;
extern GetBalanceResponseDefaultTypeInternal _GetBalanceResponse_default_instance_;
class GetOperationsRequest;
class GetOperationsRequestDefaultTypeInternal;
extern GetOperationsRequestDefaultTypeInternal _GetOperationsRequest_default_instance_;
class GetOperationsResponse;
class GetOperationsResponseDefaultTypeInternal;
extern GetOperationsResponseDefaultTypeInternal _GetOperationsResponse_default_instance_;
class GetWalletsResponse;
class GetWalletsResponseDefaultTypeInternal;
extern GetWalletsResponseDefaultTypeInternal _GetWalletsResponse_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class SetAccountSettingsRequest;
class SetAccountSettingsRequestDefaultTypeInternal;
extern SetAccountSettingsRequestDefaultTypeInternal _SetAccountSettingsRequest_default_instance_;
class SyncAccountRequest;
class SyncAccountRequestDefaultTypeInternal;
extern SyncAccountRequestDefaultTypeInternal _SyncAccountRequest_default_instance_;
class SyncAccountResponse;
class SyncAccountResponseDefaultTypeInternal;
extern SyncAccountResponseDefaultTypeInternal _SyncAccountResponse_default_instance_;
}  // namespace bitcoin
}  // namespace message
}  // namespace core
}  // namespace ledger
namespace google {
namespace protobuf {
template<> ::ledger::core::message::bitcoin::CreateAccountRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::CreateAccountRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::CreateAccountResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::CreateAccountResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::CreateWalletRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::CreateWalletRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::CreateWalletResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::CreateWalletResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::GetAccountsRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetAccountsRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::GetAccountsResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetAccountsResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::GetBalanceRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetBalanceRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::GetBalanceResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetBalanceResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::GetOperationsRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetOperationsRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::GetOperationsResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetOperationsResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::GetWalletsResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::GetWalletsResponse>(Arena*);
template<> ::ledger::core::message::bitcoin::Request* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::Request>(Arena*);
template<> ::ledger::core::message::bitcoin::SetAccountSettingsRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::SetAccountSettingsRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::SyncAccountRequest* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::SyncAccountRequest>(Arena*);
template<> ::ledger::core::message::bitcoin::SyncAccountResponse* Arena::CreateMaybeMessage<::ledger::core::message::bitcoin::SyncAccountResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ledger {
namespace core {
namespace message {
namespace bitcoin {

enum RequestType {
  SET_ACCOUNT_SETTINGS = 0,
  SET_WALLET_SETTINGS = 1,
  SET_CURRENCY_SETTINGS = 2,
  GET_WALLETS = 3,
  CREATE_WALLET = 4,
  GET_ACCOUNTS = 5,
  CREATE_ACCOUNT = 6,
  SYNC_ACCOUNT = 7,
  GET_ACCOUNT_BALANCE = 8,
  GET_OPERATIONS = 9,
  RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = SET_ACCOUNT_SETTINGS;
const RequestType RequestType_MAX = GET_OPERATIONS;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
// ===================================================================

class GetWalletsResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetWalletsResponse) */ {
 public:
  GetWalletsResponse();
  virtual ~GetWalletsResponse();

  GetWalletsResponse(const GetWalletsResponse& from);

  inline GetWalletsResponse& operator=(const GetWalletsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetWalletsResponse(GetWalletsResponse&& from) noexcept
    : GetWalletsResponse() {
    *this = ::std::move(from);
  }

  inline GetWalletsResponse& operator=(GetWalletsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetWalletsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWalletsResponse* internal_default_instance() {
    return reinterpret_cast<const GetWalletsResponse*>(
               &_GetWalletsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(GetWalletsResponse* other);
  friend void swap(GetWalletsResponse& a, GetWalletsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetWalletsResponse* New() const final {
    return CreateMaybeMessage<GetWalletsResponse>(nullptr);
  }

  GetWalletsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetWalletsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetWalletsResponse& from);
  void MergeFrom(const GetWalletsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWalletsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ledger.core.message.bitcoin.Wallet wallets = 1;
  int wallets_size() const;
  void clear_wallets();
  static const int kWalletsFieldNumber = 1;
  ::ledger::core::message::bitcoin::Wallet* mutable_wallets(int index);
  ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Wallet >*
      mutable_wallets();
  const ::ledger::core::message::bitcoin::Wallet& wallets(int index) const;
  ::ledger::core::message::bitcoin::Wallet* add_wallets();
  const ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Wallet >&
      wallets() const;

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetWalletsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Wallet > wallets_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class CreateWalletRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.CreateWalletRequest) */ {
 public:
  CreateWalletRequest();
  virtual ~CreateWalletRequest();

  CreateWalletRequest(const CreateWalletRequest& from);

  inline CreateWalletRequest& operator=(const CreateWalletRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateWalletRequest(CreateWalletRequest&& from) noexcept
    : CreateWalletRequest() {
    *this = ::std::move(from);
  }

  inline CreateWalletRequest& operator=(CreateWalletRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateWalletRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateWalletRequest* internal_default_instance() {
    return reinterpret_cast<const CreateWalletRequest*>(
               &_CreateWalletRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CreateWalletRequest* other);
  friend void swap(CreateWalletRequest& a, CreateWalletRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateWalletRequest* New() const final {
    return CreateMaybeMessage<CreateWalletRequest>(nullptr);
  }

  CreateWalletRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateWalletRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateWalletRequest& from);
  void MergeFrom(const CreateWalletRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateWalletRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string currency_name = 2;
  void clear_currency_name();
  static const int kCurrencyNameFieldNumber = 2;
  const ::std::string& currency_name() const;
  void set_currency_name(const ::std::string& value);
  #if LANG_CXX11
  void set_currency_name(::std::string&& value);
  #endif
  void set_currency_name(const char* value);
  void set_currency_name(const char* value, size_t size);
  ::std::string* mutable_currency_name();
  ::std::string* release_currency_name();
  void set_allocated_currency_name(::std::string* currency_name);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.CreateWalletRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr currency_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class CreateWalletResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.CreateWalletResponse) */ {
 public:
  CreateWalletResponse();
  virtual ~CreateWalletResponse();

  CreateWalletResponse(const CreateWalletResponse& from);

  inline CreateWalletResponse& operator=(const CreateWalletResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateWalletResponse(CreateWalletResponse&& from) noexcept
    : CreateWalletResponse() {
    *this = ::std::move(from);
  }

  inline CreateWalletResponse& operator=(CreateWalletResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateWalletResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateWalletResponse* internal_default_instance() {
    return reinterpret_cast<const CreateWalletResponse*>(
               &_CreateWalletResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CreateWalletResponse* other);
  friend void swap(CreateWalletResponse& a, CreateWalletResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateWalletResponse* New() const final {
    return CreateMaybeMessage<CreateWalletResponse>(nullptr);
  }

  CreateWalletResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateWalletResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateWalletResponse& from);
  void MergeFrom(const CreateWalletResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateWalletResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.bitcoin.Wallet wallet = 1;
  bool has_wallet() const;
  void clear_wallet();
  static const int kWalletFieldNumber = 1;
  const ::ledger::core::message::bitcoin::Wallet& wallet() const;
  ::ledger::core::message::bitcoin::Wallet* release_wallet();
  ::ledger::core::message::bitcoin::Wallet* mutable_wallet();
  void set_allocated_wallet(::ledger::core::message::bitcoin::Wallet* wallet);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.CreateWalletResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::bitcoin::Wallet* wallet_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetAccountsRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetAccountsRequest) */ {
 public:
  GetAccountsRequest();
  virtual ~GetAccountsRequest();

  GetAccountsRequest(const GetAccountsRequest& from);

  inline GetAccountsRequest& operator=(const GetAccountsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountsRequest(GetAccountsRequest&& from) noexcept
    : GetAccountsRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountsRequest& operator=(GetAccountsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetAccountsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAccountsRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountsRequest*>(
               &_GetAccountsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetAccountsRequest* other);
  friend void swap(GetAccountsRequest& a, GetAccountsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountsRequest* New() const final {
    return CreateMaybeMessage<GetAccountsRequest>(nullptr);
  }

  GetAccountsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetAccountsRequest& from);
  void MergeFrom(const GetAccountsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string wallet_uid = 1;
  void clear_wallet_uid();
  static const int kWalletUidFieldNumber = 1;
  const ::std::string& wallet_uid() const;
  void set_wallet_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_wallet_uid(::std::string&& value);
  #endif
  void set_wallet_uid(const char* value);
  void set_wallet_uid(const char* value, size_t size);
  ::std::string* mutable_wallet_uid();
  ::std::string* release_wallet_uid();
  void set_allocated_wallet_uid(::std::string* wallet_uid);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetAccountsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr wallet_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetAccountsResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetAccountsResponse) */ {
 public:
  GetAccountsResponse();
  virtual ~GetAccountsResponse();

  GetAccountsResponse(const GetAccountsResponse& from);

  inline GetAccountsResponse& operator=(const GetAccountsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetAccountsResponse(GetAccountsResponse&& from) noexcept
    : GetAccountsResponse() {
    *this = ::std::move(from);
  }

  inline GetAccountsResponse& operator=(GetAccountsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetAccountsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetAccountsResponse* internal_default_instance() {
    return reinterpret_cast<const GetAccountsResponse*>(
               &_GetAccountsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(GetAccountsResponse* other);
  friend void swap(GetAccountsResponse& a, GetAccountsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetAccountsResponse* New() const final {
    return CreateMaybeMessage<GetAccountsResponse>(nullptr);
  }

  GetAccountsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetAccountsResponse& from);
  void MergeFrom(const GetAccountsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ledger.core.message.bitcoin.Account accounts = 1;
  int accounts_size() const;
  void clear_accounts();
  static const int kAccountsFieldNumber = 1;
  ::ledger::core::message::bitcoin::Account* mutable_accounts(int index);
  ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Account >*
      mutable_accounts();
  const ::ledger::core::message::bitcoin::Account& accounts(int index) const;
  ::ledger::core::message::bitcoin::Account* add_accounts();
  const ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Account >&
      accounts() const;

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetAccountsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Account > accounts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class CreateAccountRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.CreateAccountRequest) */ {
 public:
  CreateAccountRequest();
  virtual ~CreateAccountRequest();

  CreateAccountRequest(const CreateAccountRequest& from);

  inline CreateAccountRequest& operator=(const CreateAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateAccountRequest(CreateAccountRequest&& from) noexcept
    : CreateAccountRequest() {
    *this = ::std::move(from);
  }

  inline CreateAccountRequest& operator=(CreateAccountRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateAccountRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateAccountRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAccountRequest*>(
               &_CreateAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(CreateAccountRequest* other);
  friend void swap(CreateAccountRequest& a, CreateAccountRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateAccountRequest* New() const final {
    return CreateMaybeMessage<CreateAccountRequest>(nullptr);
  }

  CreateAccountRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateAccountRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateAccountRequest& from);
  void MergeFrom(const CreateAccountRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string xpub = 1;
  void clear_xpub();
  static const int kXpubFieldNumber = 1;
  const ::std::string& xpub() const;
  void set_xpub(const ::std::string& value);
  #if LANG_CXX11
  void set_xpub(::std::string&& value);
  #endif
  void set_xpub(const char* value);
  void set_xpub(const char* value, size_t size);
  ::std::string* mutable_xpub();
  ::std::string* release_xpub();
  void set_allocated_xpub(::std::string* xpub);

  // .ledger.core.message.bitcoin.AccountConfiguration config = 3;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 3;
  const ::ledger::core::message::bitcoin::AccountConfiguration& config() const;
  ::ledger::core::message::bitcoin::AccountConfiguration* release_config();
  ::ledger::core::message::bitcoin::AccountConfiguration* mutable_config();
  void set_allocated_config(::ledger::core::message::bitcoin::AccountConfiguration* config);

  // uint32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.CreateAccountRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr xpub_;
  ::ledger::core::message::bitcoin::AccountConfiguration* config_;
  ::google::protobuf::uint32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class CreateAccountResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.CreateAccountResponse) */ {
 public:
  CreateAccountResponse();
  virtual ~CreateAccountResponse();

  CreateAccountResponse(const CreateAccountResponse& from);

  inline CreateAccountResponse& operator=(const CreateAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateAccountResponse(CreateAccountResponse&& from) noexcept
    : CreateAccountResponse() {
    *this = ::std::move(from);
  }

  inline CreateAccountResponse& operator=(CreateAccountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateAccountResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateAccountResponse* internal_default_instance() {
    return reinterpret_cast<const CreateAccountResponse*>(
               &_CreateAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CreateAccountResponse* other);
  friend void swap(CreateAccountResponse& a, CreateAccountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateAccountResponse* New() const final {
    return CreateMaybeMessage<CreateAccountResponse>(nullptr);
  }

  CreateAccountResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateAccountResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateAccountResponse& from);
  void MergeFrom(const CreateAccountResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAccountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.bitcoin.Account created_account = 1;
  bool has_created_account() const;
  void clear_created_account();
  static const int kCreatedAccountFieldNumber = 1;
  const ::ledger::core::message::bitcoin::Account& created_account() const;
  ::ledger::core::message::bitcoin::Account* release_created_account();
  ::ledger::core::message::bitcoin::Account* mutable_created_account();
  void set_allocated_created_account(::ledger::core::message::bitcoin::Account* created_account);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.CreateAccountResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::bitcoin::Account* created_account_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class SyncAccountRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.SyncAccountRequest) */ {
 public:
  SyncAccountRequest();
  virtual ~SyncAccountRequest();

  SyncAccountRequest(const SyncAccountRequest& from);

  inline SyncAccountRequest& operator=(const SyncAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyncAccountRequest(SyncAccountRequest&& from) noexcept
    : SyncAccountRequest() {
    *this = ::std::move(from);
  }

  inline SyncAccountRequest& operator=(SyncAccountRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SyncAccountRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyncAccountRequest* internal_default_instance() {
    return reinterpret_cast<const SyncAccountRequest*>(
               &_SyncAccountRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SyncAccountRequest* other);
  friend void swap(SyncAccountRequest& a, SyncAccountRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyncAccountRequest* New() const final {
    return CreateMaybeMessage<SyncAccountRequest>(nullptr);
  }

  SyncAccountRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyncAccountRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SyncAccountRequest& from);
  void MergeFrom(const SyncAccountRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncAccountRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string acc_uid = 1;
  void clear_acc_uid();
  static const int kAccUidFieldNumber = 1;
  const ::std::string& acc_uid() const;
  void set_acc_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_acc_uid(::std::string&& value);
  #endif
  void set_acc_uid(const char* value);
  void set_acc_uid(const char* value, size_t size);
  ::std::string* mutable_acc_uid();
  ::std::string* release_acc_uid();
  void set_allocated_acc_uid(::std::string* acc_uid);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.SyncAccountRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr acc_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class SyncAccountResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.SyncAccountResponse) */ {
 public:
  SyncAccountResponse();
  virtual ~SyncAccountResponse();

  SyncAccountResponse(const SyncAccountResponse& from);

  inline SyncAccountResponse& operator=(const SyncAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SyncAccountResponse(SyncAccountResponse&& from) noexcept
    : SyncAccountResponse() {
    *this = ::std::move(from);
  }

  inline SyncAccountResponse& operator=(SyncAccountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SyncAccountResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SyncAccountResponse* internal_default_instance() {
    return reinterpret_cast<const SyncAccountResponse*>(
               &_SyncAccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(SyncAccountResponse* other);
  friend void swap(SyncAccountResponse& a, SyncAccountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SyncAccountResponse* New() const final {
    return CreateMaybeMessage<SyncAccountResponse>(nullptr);
  }

  SyncAccountResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SyncAccountResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SyncAccountResponse& from);
  void MergeFrom(const SyncAccountResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SyncAccountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool new_acc = 1;
  void clear_new_acc();
  static const int kNewAccFieldNumber = 1;
  bool new_acc() const;
  void set_new_acc(bool value);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.SyncAccountResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool new_acc_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetBalanceRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetBalanceRequest) */ {
 public:
  GetBalanceRequest();
  virtual ~GetBalanceRequest();

  GetBalanceRequest(const GetBalanceRequest& from);

  inline GetBalanceRequest& operator=(const GetBalanceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBalanceRequest(GetBalanceRequest&& from) noexcept
    : GetBalanceRequest() {
    *this = ::std::move(from);
  }

  inline GetBalanceRequest& operator=(GetBalanceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetBalanceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBalanceRequest* internal_default_instance() {
    return reinterpret_cast<const GetBalanceRequest*>(
               &_GetBalanceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetBalanceRequest* other);
  friend void swap(GetBalanceRequest& a, GetBalanceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBalanceRequest* New() const final {
    return CreateMaybeMessage<GetBalanceRequest>(nullptr);
  }

  GetBalanceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBalanceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBalanceRequest& from);
  void MergeFrom(const GetBalanceRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBalanceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string acc_uid = 1;
  void clear_acc_uid();
  static const int kAccUidFieldNumber = 1;
  const ::std::string& acc_uid() const;
  void set_acc_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_acc_uid(::std::string&& value);
  #endif
  void set_acc_uid(const char* value);
  void set_acc_uid(const char* value, size_t size);
  ::std::string* mutable_acc_uid();
  ::std::string* release_acc_uid();
  void set_allocated_acc_uid(::std::string* acc_uid);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetBalanceRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr acc_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetBalanceResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetBalanceResponse) */ {
 public:
  GetBalanceResponse();
  virtual ~GetBalanceResponse();

  GetBalanceResponse(const GetBalanceResponse& from);

  inline GetBalanceResponse& operator=(const GetBalanceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetBalanceResponse(GetBalanceResponse&& from) noexcept
    : GetBalanceResponse() {
    *this = ::std::move(from);
  }

  inline GetBalanceResponse& operator=(GetBalanceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetBalanceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetBalanceResponse* internal_default_instance() {
    return reinterpret_cast<const GetBalanceResponse*>(
               &_GetBalanceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetBalanceResponse* other);
  friend void swap(GetBalanceResponse& a, GetBalanceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetBalanceResponse* New() const final {
    return CreateMaybeMessage<GetBalanceResponse>(nullptr);
  }

  GetBalanceResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetBalanceResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetBalanceResponse& from);
  void MergeFrom(const GetBalanceResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBalanceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ledger.core.message.common.Amount amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  const ::ledger::core::message::common::Amount& amount() const;
  ::ledger::core::message::common::Amount* release_amount();
  ::ledger::core::message::common::Amount* mutable_amount();
  void set_allocated_amount(::ledger::core::message::common::Amount* amount);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetBalanceResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ledger::core::message::common::Amount* amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetOperationsRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetOperationsRequest) */ {
 public:
  GetOperationsRequest();
  virtual ~GetOperationsRequest();

  GetOperationsRequest(const GetOperationsRequest& from);

  inline GetOperationsRequest& operator=(const GetOperationsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOperationsRequest(GetOperationsRequest&& from) noexcept
    : GetOperationsRequest() {
    *this = ::std::move(from);
  }

  inline GetOperationsRequest& operator=(GetOperationsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetOperationsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOperationsRequest* internal_default_instance() {
    return reinterpret_cast<const GetOperationsRequest*>(
               &_GetOperationsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetOperationsRequest* other);
  friend void swap(GetOperationsRequest& a, GetOperationsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOperationsRequest* New() const final {
    return CreateMaybeMessage<GetOperationsRequest>(nullptr);
  }

  GetOperationsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOperationsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOperationsRequest& from);
  void MergeFrom(const GetOperationsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOperationsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string acc_uid = 1;
  void clear_acc_uid();
  static const int kAccUidFieldNumber = 1;
  const ::std::string& acc_uid() const;
  void set_acc_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_acc_uid(::std::string&& value);
  #endif
  void set_acc_uid(const char* value);
  void set_acc_uid(const char* value, size_t size);
  ::std::string* mutable_acc_uid();
  ::std::string* release_acc_uid();
  void set_allocated_acc_uid(::std::string* acc_uid);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetOperationsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr acc_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class GetOperationsResponse :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.GetOperationsResponse) */ {
 public:
  GetOperationsResponse();
  virtual ~GetOperationsResponse();

  GetOperationsResponse(const GetOperationsResponse& from);

  inline GetOperationsResponse& operator=(const GetOperationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOperationsResponse(GetOperationsResponse&& from) noexcept
    : GetOperationsResponse() {
    *this = ::std::move(from);
  }

  inline GetOperationsResponse& operator=(GetOperationsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetOperationsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOperationsResponse* internal_default_instance() {
    return reinterpret_cast<const GetOperationsResponse*>(
               &_GetOperationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetOperationsResponse* other);
  friend void swap(GetOperationsResponse& a, GetOperationsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOperationsResponse* New() const final {
    return CreateMaybeMessage<GetOperationsResponse>(nullptr);
  }

  GetOperationsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOperationsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOperationsResponse& from);
  void MergeFrom(const GetOperationsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOperationsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ledger.core.message.bitcoin.Operation operations = 1;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 1;
  ::ledger::core::message::bitcoin::Operation* mutable_operations(int index);
  ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation >*
      mutable_operations();
  const ::ledger::core::message::bitcoin::Operation& operations(int index) const;
  ::ledger::core::message::bitcoin::Operation* add_operations();
  const ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation >&
      operations() const;

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.GetOperationsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation > operations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class SetAccountSettingsRequest :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.SetAccountSettingsRequest) */ {
 public:
  SetAccountSettingsRequest();
  virtual ~SetAccountSettingsRequest();

  SetAccountSettingsRequest(const SetAccountSettingsRequest& from);

  inline SetAccountSettingsRequest& operator=(const SetAccountSettingsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetAccountSettingsRequest(SetAccountSettingsRequest&& from) noexcept
    : SetAccountSettingsRequest() {
    *this = ::std::move(from);
  }

  inline SetAccountSettingsRequest& operator=(SetAccountSettingsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SetAccountSettingsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetAccountSettingsRequest* internal_default_instance() {
    return reinterpret_cast<const SetAccountSettingsRequest*>(
               &_SetAccountSettingsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(SetAccountSettingsRequest* other);
  friend void swap(SetAccountSettingsRequest& a, SetAccountSettingsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetAccountSettingsRequest* New() const final {
    return CreateMaybeMessage<SetAccountSettingsRequest>(nullptr);
  }

  SetAccountSettingsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetAccountSettingsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetAccountSettingsRequest& from);
  void MergeFrom(const SetAccountSettingsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAccountSettingsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string acc_uid = 1;
  void clear_acc_uid();
  static const int kAccUidFieldNumber = 1;
  const ::std::string& acc_uid() const;
  void set_acc_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_acc_uid(::std::string&& value);
  #endif
  void set_acc_uid(const char* value);
  void set_acc_uid(const char* value, size_t size);
  ::std::string* mutable_acc_uid();
  ::std::string* release_acc_uid();
  void set_allocated_acc_uid(::std::string* acc_uid);

  // .ledger.core.message.bitcoin.AccountSettings settings = 2;
  bool has_settings() const;
  void clear_settings();
  static const int kSettingsFieldNumber = 2;
  const ::ledger::core::message::bitcoin::AccountSettings& settings() const;
  ::ledger::core::message::bitcoin::AccountSettings* release_settings();
  ::ledger::core::message::bitcoin::AccountSettings* mutable_settings();
  void set_allocated_settings(::ledger::core::message::bitcoin::AccountSettings* settings);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.SetAccountSettingsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr acc_uid_;
  ::ledger::core::message::bitcoin::AccountSettings* settings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// -------------------------------------------------------------------

class Request :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ledger.core.message.bitcoin.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(Request&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Request& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Request* other);
  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Request* New() const final {
    return CreateMaybeMessage<Request>(nullptr);
  }

  Request* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes submessage = 2;
  void clear_submessage();
  static const int kSubmessageFieldNumber = 2;
  const ::std::string& submessage() const;
  void set_submessage(const ::std::string& value);
  #if LANG_CXX11
  void set_submessage(::std::string&& value);
  #endif
  void set_submessage(const char* value);
  void set_submessage(const void* value, size_t size);
  ::std::string* mutable_submessage();
  ::std::string* release_submessage();
  void set_allocated_submessage(::std::string* submessage);

  // .ledger.core.message.bitcoin.RequestType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ledger::core::message::bitcoin::RequestType type() const;
  void set_type(::ledger::core::message::bitcoin::RequestType value);

  // @@protoc_insertion_point(class_scope:ledger.core.message.bitcoin.Request)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr submessage_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_bitcoin_2fcommands_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetWalletsResponse

// repeated .ledger.core.message.bitcoin.Wallet wallets = 1;
inline int GetWalletsResponse::wallets_size() const {
  return wallets_.size();
}
inline ::ledger::core::message::bitcoin::Wallet* GetWalletsResponse::mutable_wallets(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetWalletsResponse.wallets)
  return wallets_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Wallet >*
GetWalletsResponse::mutable_wallets() {
  // @@protoc_insertion_point(field_mutable_list:ledger.core.message.bitcoin.GetWalletsResponse.wallets)
  return &wallets_;
}
inline const ::ledger::core::message::bitcoin::Wallet& GetWalletsResponse::wallets(int index) const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetWalletsResponse.wallets)
  return wallets_.Get(index);
}
inline ::ledger::core::message::bitcoin::Wallet* GetWalletsResponse::add_wallets() {
  // @@protoc_insertion_point(field_add:ledger.core.message.bitcoin.GetWalletsResponse.wallets)
  return wallets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Wallet >&
GetWalletsResponse::wallets() const {
  // @@protoc_insertion_point(field_list:ledger.core.message.bitcoin.GetWalletsResponse.wallets)
  return wallets_;
}

// -------------------------------------------------------------------

// CreateWalletRequest

// string name = 1;
inline void CreateWalletRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateWalletRequest::name() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.CreateWalletRequest.name)
  return name_.GetNoArena();
}
inline void CreateWalletRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.CreateWalletRequest.name)
}
#if LANG_CXX11
inline void CreateWalletRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.CreateWalletRequest.name)
}
#endif
inline void CreateWalletRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.CreateWalletRequest.name)
}
inline void CreateWalletRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.CreateWalletRequest.name)
}
inline ::std::string* CreateWalletRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.CreateWalletRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateWalletRequest::release_name() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.CreateWalletRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateWalletRequest::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.CreateWalletRequest.name)
}

// string currency_name = 2;
inline void CreateWalletRequest::clear_currency_name() {
  currency_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateWalletRequest::currency_name() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.CreateWalletRequest.currency_name)
  return currency_name_.GetNoArena();
}
inline void CreateWalletRequest::set_currency_name(const ::std::string& value) {
  
  currency_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.CreateWalletRequest.currency_name)
}
#if LANG_CXX11
inline void CreateWalletRequest::set_currency_name(::std::string&& value) {
  
  currency_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.CreateWalletRequest.currency_name)
}
#endif
inline void CreateWalletRequest::set_currency_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  currency_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.CreateWalletRequest.currency_name)
}
inline void CreateWalletRequest::set_currency_name(const char* value, size_t size) {
  
  currency_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.CreateWalletRequest.currency_name)
}
inline ::std::string* CreateWalletRequest::mutable_currency_name() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.CreateWalletRequest.currency_name)
  return currency_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateWalletRequest::release_currency_name() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.CreateWalletRequest.currency_name)
  
  return currency_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateWalletRequest::set_allocated_currency_name(::std::string* currency_name) {
  if (currency_name != nullptr) {
    
  } else {
    
  }
  currency_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), currency_name);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.CreateWalletRequest.currency_name)
}

// -------------------------------------------------------------------

// CreateWalletResponse

// .ledger.core.message.bitcoin.Wallet wallet = 1;
inline bool CreateWalletResponse::has_wallet() const {
  return this != internal_default_instance() && wallet_ != nullptr;
}
inline const ::ledger::core::message::bitcoin::Wallet& CreateWalletResponse::wallet() const {
  const ::ledger::core::message::bitcoin::Wallet* p = wallet_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.CreateWalletResponse.wallet)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::Wallet*>(
      &::ledger::core::message::bitcoin::_Wallet_default_instance_);
}
inline ::ledger::core::message::bitcoin::Wallet* CreateWalletResponse::release_wallet() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.CreateWalletResponse.wallet)
  
  ::ledger::core::message::bitcoin::Wallet* temp = wallet_;
  wallet_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::Wallet* CreateWalletResponse::mutable_wallet() {
  
  if (wallet_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::Wallet>(GetArenaNoVirtual());
    wallet_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.CreateWalletResponse.wallet)
  return wallet_;
}
inline void CreateWalletResponse::set_allocated_wallet(::ledger::core::message::bitcoin::Wallet* wallet) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(wallet_);
  }
  if (wallet) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wallet = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wallet, submessage_arena);
    }
    
  } else {
    
  }
  wallet_ = wallet;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.CreateWalletResponse.wallet)
}

// -------------------------------------------------------------------

// GetAccountsRequest

// string wallet_uid = 1;
inline void GetAccountsRequest::clear_wallet_uid() {
  wallet_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetAccountsRequest::wallet_uid() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetAccountsRequest.wallet_uid)
  return wallet_uid_.GetNoArena();
}
inline void GetAccountsRequest::set_wallet_uid(const ::std::string& value) {
  
  wallet_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.GetAccountsRequest.wallet_uid)
}
#if LANG_CXX11
inline void GetAccountsRequest::set_wallet_uid(::std::string&& value) {
  
  wallet_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.GetAccountsRequest.wallet_uid)
}
#endif
inline void GetAccountsRequest::set_wallet_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  wallet_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.GetAccountsRequest.wallet_uid)
}
inline void GetAccountsRequest::set_wallet_uid(const char* value, size_t size) {
  
  wallet_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.GetAccountsRequest.wallet_uid)
}
inline ::std::string* GetAccountsRequest::mutable_wallet_uid() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetAccountsRequest.wallet_uid)
  return wallet_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetAccountsRequest::release_wallet_uid() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetAccountsRequest.wallet_uid)
  
  return wallet_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetAccountsRequest::set_allocated_wallet_uid(::std::string* wallet_uid) {
  if (wallet_uid != nullptr) {
    
  } else {
    
  }
  wallet_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wallet_uid);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetAccountsRequest.wallet_uid)
}

// -------------------------------------------------------------------

// GetAccountsResponse

// repeated .ledger.core.message.bitcoin.Account accounts = 1;
inline int GetAccountsResponse::accounts_size() const {
  return accounts_.size();
}
inline ::ledger::core::message::bitcoin::Account* GetAccountsResponse::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetAccountsResponse.accounts)
  return accounts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Account >*
GetAccountsResponse::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:ledger.core.message.bitcoin.GetAccountsResponse.accounts)
  return &accounts_;
}
inline const ::ledger::core::message::bitcoin::Account& GetAccountsResponse::accounts(int index) const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetAccountsResponse.accounts)
  return accounts_.Get(index);
}
inline ::ledger::core::message::bitcoin::Account* GetAccountsResponse::add_accounts() {
  // @@protoc_insertion_point(field_add:ledger.core.message.bitcoin.GetAccountsResponse.accounts)
  return accounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Account >&
GetAccountsResponse::accounts() const {
  // @@protoc_insertion_point(field_list:ledger.core.message.bitcoin.GetAccountsResponse.accounts)
  return accounts_;
}

// -------------------------------------------------------------------

// CreateAccountRequest

// string xpub = 1;
inline void CreateAccountRequest::clear_xpub() {
  xpub_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateAccountRequest::xpub() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.CreateAccountRequest.xpub)
  return xpub_.GetNoArena();
}
inline void CreateAccountRequest::set_xpub(const ::std::string& value) {
  
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.CreateAccountRequest.xpub)
}
#if LANG_CXX11
inline void CreateAccountRequest::set_xpub(::std::string&& value) {
  
  xpub_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.CreateAccountRequest.xpub)
}
#endif
inline void CreateAccountRequest::set_xpub(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.CreateAccountRequest.xpub)
}
inline void CreateAccountRequest::set_xpub(const char* value, size_t size) {
  
  xpub_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.CreateAccountRequest.xpub)
}
inline ::std::string* CreateAccountRequest::mutable_xpub() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.CreateAccountRequest.xpub)
  return xpub_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateAccountRequest::release_xpub() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.CreateAccountRequest.xpub)
  
  return xpub_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateAccountRequest::set_allocated_xpub(::std::string* xpub) {
  if (xpub != nullptr) {
    
  } else {
    
  }
  xpub_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), xpub);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.CreateAccountRequest.xpub)
}

// uint32 index = 2;
inline void CreateAccountRequest::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 CreateAccountRequest::index() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.CreateAccountRequest.index)
  return index_;
}
inline void CreateAccountRequest::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.CreateAccountRequest.index)
}

// .ledger.core.message.bitcoin.AccountConfiguration config = 3;
inline bool CreateAccountRequest::has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline const ::ledger::core::message::bitcoin::AccountConfiguration& CreateAccountRequest::config() const {
  const ::ledger::core::message::bitcoin::AccountConfiguration* p = config_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.CreateAccountRequest.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::AccountConfiguration*>(
      &::ledger::core::message::bitcoin::_AccountConfiguration_default_instance_);
}
inline ::ledger::core::message::bitcoin::AccountConfiguration* CreateAccountRequest::release_config() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.CreateAccountRequest.config)
  
  ::ledger::core::message::bitcoin::AccountConfiguration* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::AccountConfiguration* CreateAccountRequest::mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::AccountConfiguration>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.CreateAccountRequest.config)
  return config_;
}
inline void CreateAccountRequest::set_allocated_config(::ledger::core::message::bitcoin::AccountConfiguration* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(config_);
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.CreateAccountRequest.config)
}

// -------------------------------------------------------------------

// CreateAccountResponse

// .ledger.core.message.bitcoin.Account created_account = 1;
inline bool CreateAccountResponse::has_created_account() const {
  return this != internal_default_instance() && created_account_ != nullptr;
}
inline const ::ledger::core::message::bitcoin::Account& CreateAccountResponse::created_account() const {
  const ::ledger::core::message::bitcoin::Account* p = created_account_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.CreateAccountResponse.created_account)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::Account*>(
      &::ledger::core::message::bitcoin::_Account_default_instance_);
}
inline ::ledger::core::message::bitcoin::Account* CreateAccountResponse::release_created_account() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.CreateAccountResponse.created_account)
  
  ::ledger::core::message::bitcoin::Account* temp = created_account_;
  created_account_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::Account* CreateAccountResponse::mutable_created_account() {
  
  if (created_account_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::Account>(GetArenaNoVirtual());
    created_account_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.CreateAccountResponse.created_account)
  return created_account_;
}
inline void CreateAccountResponse::set_allocated_created_account(::ledger::core::message::bitcoin::Account* created_account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_account_);
  }
  if (created_account) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      created_account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created_account, submessage_arena);
    }
    
  } else {
    
  }
  created_account_ = created_account;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.CreateAccountResponse.created_account)
}

// -------------------------------------------------------------------

// SyncAccountRequest

// string acc_uid = 1;
inline void SyncAccountRequest::clear_acc_uid() {
  acc_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SyncAccountRequest::acc_uid() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.SyncAccountRequest.acc_uid)
  return acc_uid_.GetNoArena();
}
inline void SyncAccountRequest::set_acc_uid(const ::std::string& value) {
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.SyncAccountRequest.acc_uid)
}
#if LANG_CXX11
inline void SyncAccountRequest::set_acc_uid(::std::string&& value) {
  
  acc_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.SyncAccountRequest.acc_uid)
}
#endif
inline void SyncAccountRequest::set_acc_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.SyncAccountRequest.acc_uid)
}
inline void SyncAccountRequest::set_acc_uid(const char* value, size_t size) {
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.SyncAccountRequest.acc_uid)
}
inline ::std::string* SyncAccountRequest::mutable_acc_uid() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.SyncAccountRequest.acc_uid)
  return acc_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SyncAccountRequest::release_acc_uid() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.SyncAccountRequest.acc_uid)
  
  return acc_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SyncAccountRequest::set_allocated_acc_uid(::std::string* acc_uid) {
  if (acc_uid != nullptr) {
    
  } else {
    
  }
  acc_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), acc_uid);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.SyncAccountRequest.acc_uid)
}

// -------------------------------------------------------------------

// SyncAccountResponse

// bool new_acc = 1;
inline void SyncAccountResponse::clear_new_acc() {
  new_acc_ = false;
}
inline bool SyncAccountResponse::new_acc() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.SyncAccountResponse.new_acc)
  return new_acc_;
}
inline void SyncAccountResponse::set_new_acc(bool value) {
  
  new_acc_ = value;
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.SyncAccountResponse.new_acc)
}

// -------------------------------------------------------------------

// GetBalanceRequest

// string acc_uid = 1;
inline void GetBalanceRequest::clear_acc_uid() {
  acc_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetBalanceRequest::acc_uid() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetBalanceRequest.acc_uid)
  return acc_uid_.GetNoArena();
}
inline void GetBalanceRequest::set_acc_uid(const ::std::string& value) {
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.GetBalanceRequest.acc_uid)
}
#if LANG_CXX11
inline void GetBalanceRequest::set_acc_uid(::std::string&& value) {
  
  acc_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.GetBalanceRequest.acc_uid)
}
#endif
inline void GetBalanceRequest::set_acc_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.GetBalanceRequest.acc_uid)
}
inline void GetBalanceRequest::set_acc_uid(const char* value, size_t size) {
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.GetBalanceRequest.acc_uid)
}
inline ::std::string* GetBalanceRequest::mutable_acc_uid() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetBalanceRequest.acc_uid)
  return acc_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetBalanceRequest::release_acc_uid() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetBalanceRequest.acc_uid)
  
  return acc_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetBalanceRequest::set_allocated_acc_uid(::std::string* acc_uid) {
  if (acc_uid != nullptr) {
    
  } else {
    
  }
  acc_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), acc_uid);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetBalanceRequest.acc_uid)
}

// -------------------------------------------------------------------

// GetBalanceResponse

// .ledger.core.message.common.Amount amount = 1;
inline bool GetBalanceResponse::has_amount() const {
  return this != internal_default_instance() && amount_ != nullptr;
}
inline const ::ledger::core::message::common::Amount& GetBalanceResponse::amount() const {
  const ::ledger::core::message::common::Amount* p = amount_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetBalanceResponse.amount)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::common::Amount*>(
      &::ledger::core::message::common::_Amount_default_instance_);
}
inline ::ledger::core::message::common::Amount* GetBalanceResponse::release_amount() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetBalanceResponse.amount)
  
  ::ledger::core::message::common::Amount* temp = amount_;
  amount_ = nullptr;
  return temp;
}
inline ::ledger::core::message::common::Amount* GetBalanceResponse::mutable_amount() {
  
  if (amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::common::Amount>(GetArenaNoVirtual());
    amount_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetBalanceResponse.amount)
  return amount_;
}
inline void GetBalanceResponse::set_allocated_amount(::ledger::core::message::common::Amount* amount) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(amount_);
  }
  if (amount) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      amount = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    
  } else {
    
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetBalanceResponse.amount)
}

// -------------------------------------------------------------------

// GetOperationsRequest

// string acc_uid = 1;
inline void GetOperationsRequest::clear_acc_uid() {
  acc_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetOperationsRequest::acc_uid() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetOperationsRequest.acc_uid)
  return acc_uid_.GetNoArena();
}
inline void GetOperationsRequest::set_acc_uid(const ::std::string& value) {
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.GetOperationsRequest.acc_uid)
}
#if LANG_CXX11
inline void GetOperationsRequest::set_acc_uid(::std::string&& value) {
  
  acc_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.GetOperationsRequest.acc_uid)
}
#endif
inline void GetOperationsRequest::set_acc_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.GetOperationsRequest.acc_uid)
}
inline void GetOperationsRequest::set_acc_uid(const char* value, size_t size) {
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.GetOperationsRequest.acc_uid)
}
inline ::std::string* GetOperationsRequest::mutable_acc_uid() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetOperationsRequest.acc_uid)
  return acc_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetOperationsRequest::release_acc_uid() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.GetOperationsRequest.acc_uid)
  
  return acc_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetOperationsRequest::set_allocated_acc_uid(::std::string* acc_uid) {
  if (acc_uid != nullptr) {
    
  } else {
    
  }
  acc_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), acc_uid);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.GetOperationsRequest.acc_uid)
}

// -------------------------------------------------------------------

// GetOperationsResponse

// repeated .ledger.core.message.bitcoin.Operation operations = 1;
inline int GetOperationsResponse::operations_size() const {
  return operations_.size();
}
inline ::ledger::core::message::bitcoin::Operation* GetOperationsResponse::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return operations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation >*
GetOperationsResponse::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return &operations_;
}
inline const ::ledger::core::message::bitcoin::Operation& GetOperationsResponse::operations(int index) const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return operations_.Get(index);
}
inline ::ledger::core::message::bitcoin::Operation* GetOperationsResponse::add_operations() {
  // @@protoc_insertion_point(field_add:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return operations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ledger::core::message::bitcoin::Operation >&
GetOperationsResponse::operations() const {
  // @@protoc_insertion_point(field_list:ledger.core.message.bitcoin.GetOperationsResponse.operations)
  return operations_;
}

// -------------------------------------------------------------------

// SetAccountSettingsRequest

// string acc_uid = 1;
inline void SetAccountSettingsRequest::clear_acc_uid() {
  acc_uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetAccountSettingsRequest::acc_uid() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.SetAccountSettingsRequest.acc_uid)
  return acc_uid_.GetNoArena();
}
inline void SetAccountSettingsRequest::set_acc_uid(const ::std::string& value) {
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.SetAccountSettingsRequest.acc_uid)
}
#if LANG_CXX11
inline void SetAccountSettingsRequest::set_acc_uid(::std::string&& value) {
  
  acc_uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.SetAccountSettingsRequest.acc_uid)
}
#endif
inline void SetAccountSettingsRequest::set_acc_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.SetAccountSettingsRequest.acc_uid)
}
inline void SetAccountSettingsRequest::set_acc_uid(const char* value, size_t size) {
  
  acc_uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.SetAccountSettingsRequest.acc_uid)
}
inline ::std::string* SetAccountSettingsRequest::mutable_acc_uid() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.SetAccountSettingsRequest.acc_uid)
  return acc_uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetAccountSettingsRequest::release_acc_uid() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.SetAccountSettingsRequest.acc_uid)
  
  return acc_uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetAccountSettingsRequest::set_allocated_acc_uid(::std::string* acc_uid) {
  if (acc_uid != nullptr) {
    
  } else {
    
  }
  acc_uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), acc_uid);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.SetAccountSettingsRequest.acc_uid)
}

// .ledger.core.message.bitcoin.AccountSettings settings = 2;
inline bool SetAccountSettingsRequest::has_settings() const {
  return this != internal_default_instance() && settings_ != nullptr;
}
inline const ::ledger::core::message::bitcoin::AccountSettings& SetAccountSettingsRequest::settings() const {
  const ::ledger::core::message::bitcoin::AccountSettings* p = settings_;
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.SetAccountSettingsRequest.settings)
  return p != nullptr ? *p : *reinterpret_cast<const ::ledger::core::message::bitcoin::AccountSettings*>(
      &::ledger::core::message::bitcoin::_AccountSettings_default_instance_);
}
inline ::ledger::core::message::bitcoin::AccountSettings* SetAccountSettingsRequest::release_settings() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.SetAccountSettingsRequest.settings)
  
  ::ledger::core::message::bitcoin::AccountSettings* temp = settings_;
  settings_ = nullptr;
  return temp;
}
inline ::ledger::core::message::bitcoin::AccountSettings* SetAccountSettingsRequest::mutable_settings() {
  
  if (settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::ledger::core::message::bitcoin::AccountSettings>(GetArenaNoVirtual());
    settings_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.SetAccountSettingsRequest.settings)
  return settings_;
}
inline void SetAccountSettingsRequest::set_allocated_settings(::ledger::core::message::bitcoin::AccountSettings* settings) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(settings_);
  }
  if (settings) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      settings = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, settings, submessage_arena);
    }
    
  } else {
    
  }
  settings_ = settings;
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.SetAccountSettingsRequest.settings)
}

// -------------------------------------------------------------------

// Request

// .ledger.core.message.bitcoin.RequestType type = 1;
inline void Request::clear_type() {
  type_ = 0;
}
inline ::ledger::core::message::bitcoin::RequestType Request::type() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.Request.type)
  return static_cast< ::ledger::core::message::bitcoin::RequestType >(type_);
}
inline void Request::set_type(::ledger::core::message::bitcoin::RequestType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.Request.type)
}

// bytes submessage = 2;
inline void Request::clear_submessage() {
  submessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Request::submessage() const {
  // @@protoc_insertion_point(field_get:ledger.core.message.bitcoin.Request.submessage)
  return submessage_.GetNoArena();
}
inline void Request::set_submessage(const ::std::string& value) {
  
  submessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ledger.core.message.bitcoin.Request.submessage)
}
#if LANG_CXX11
inline void Request::set_submessage(::std::string&& value) {
  
  submessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ledger.core.message.bitcoin.Request.submessage)
}
#endif
inline void Request::set_submessage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  submessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ledger.core.message.bitcoin.Request.submessage)
}
inline void Request::set_submessage(const void* value, size_t size) {
  
  submessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ledger.core.message.bitcoin.Request.submessage)
}
inline ::std::string* Request::mutable_submessage() {
  
  // @@protoc_insertion_point(field_mutable:ledger.core.message.bitcoin.Request.submessage)
  return submessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Request::release_submessage() {
  // @@protoc_insertion_point(field_release:ledger.core.message.bitcoin.Request.submessage)
  
  return submessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Request::set_allocated_submessage(::std::string* submessage) {
  if (submessage != nullptr) {
    
  } else {
    
  }
  submessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), submessage);
  // @@protoc_insertion_point(field_set_allocated:ledger.core.message.bitcoin.Request.submessage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bitcoin
}  // namespace message
}  // namespace core
}  // namespace ledger

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ledger::core::message::bitcoin::RequestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ledger::core::message::bitcoin::RequestType>() {
  return ::ledger::core::message::bitcoin::RequestType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_bitcoin_2fcommands_2eproto
